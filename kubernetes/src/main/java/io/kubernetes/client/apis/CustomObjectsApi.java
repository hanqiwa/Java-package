/*
 * Kubernetes
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1.12.2
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.kubernetes.client.apis;

import com.google.gson.reflect.TypeToken;
import io.kubernetes.client.ApiCallback;
import io.kubernetes.client.ApiClient;
import io.kubernetes.client.ApiException;
import io.kubernetes.client.ApiResponse;
import io.kubernetes.client.Configuration;
import io.kubernetes.client.Pair;
import io.kubernetes.client.ProgressRequestBody;
import io.kubernetes.client.ProgressResponseBody;
import io.kubernetes.client.models.V1DeleteOptions;
import java.io.IOException;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import okhttp3.Call;
import okhttp3.Interceptor;
import okhttp3.Response;

public class CustomObjectsApi {
  private ApiClient apiClient;

  public CustomObjectsApi() {
    this(Configuration.getDefaultApiClient());
  }

  public CustomObjectsApi(ApiClient apiClient) {
    this.apiClient = apiClient;
  }

  public ApiClient getApiClient() {
    return apiClient;
  }

  public void setApiClient(ApiClient apiClient) {
    this.apiClient = apiClient;
  }

  /**
   * Build call for createClusterCustomObject
   *
   * @param group The custom resource&#39;s group name (required)
   * @param version The custom resource&#39;s version (required)
   * @param plural The custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param body The JSON schema of the Resource to create. (required)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param progressListener Progress listener
   * @param progressRequestListener Progress request listener
   * @return Call to execute
   * @throws ApiException If fail to serialize the request body object
   */
  public Call createClusterCustomObjectCall(
      String group,
      String version,
      String plural,
      Object body,
      String pretty,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {
    Object localVarPostBody = body;

    // create path and map variables
    String localVarPath =
        "/apis/{group}/{version}/{plural}"
            .replaceAll("\\{" + "group" + "\\}", apiClient.escapeString(group.toString()))
            .replaceAll("\\{" + "version" + "\\}", apiClient.escapeString(version.toString()))
            .replaceAll("\\{" + "plural" + "\\}", apiClient.escapeString(plural.toString()));

    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    if (pretty != null) localVarQueryParams.addAll(apiClient.parameterToPair("pretty", pretty));

    Map<String, String> localVarHeaderParams = new HashMap<String, String>();

    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    final String[] localVarAccepts = {"application/json"};
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
    if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

    final String[] localVarContentTypes = {};

    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
    localVarHeaderParams.put("Content-Type", localVarContentType);

    if (progressListener != null) {
      apiClient
          .getHttpClient()
          .networkInterceptors()
          .add(
              new Interceptor() {
                @Override
                public Response intercept(Interceptor.Chain chain) throws IOException {
                  Response originalResponse = chain.proceed(chain.request());
                  return originalResponse
                      .newBuilder()
                      .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                      .build();
                }
              });
    }

    String[] localVarAuthNames = new String[] {"BearerToken"};
    return apiClient.buildCall(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarFormParams,
        localVarAuthNames,
        progressRequestListener);
  }

  @SuppressWarnings("rawtypes")
  private Call createClusterCustomObjectValidateBeforeCall(
      String group,
      String version,
      String plural,
      Object body,
      String pretty,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {

    // verify the required parameter 'group' is set
    if (group == null) {
      throw new ApiException(
          "Missing the required parameter 'group' when calling createClusterCustomObject(Async)");
    }

    // verify the required parameter 'version' is set
    if (version == null) {
      throw new ApiException(
          "Missing the required parameter 'version' when calling createClusterCustomObject(Async)");
    }

    // verify the required parameter 'plural' is set
    if (plural == null) {
      throw new ApiException(
          "Missing the required parameter 'plural' when calling createClusterCustomObject(Async)");
    }

    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(
          "Missing the required parameter 'body' when calling createClusterCustomObject(Async)");
    }

    Call call =
        createClusterCustomObjectCall(
            group, version, plural, body, pretty, progressListener, progressRequestListener);
    return call;
  }

  /**
   * Creates a cluster scoped Custom object
   *
   * @param group The custom resource&#39;s group name (required)
   * @param version The custom resource&#39;s version (required)
   * @param plural The custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param body The JSON schema of the Resource to create. (required)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return Object
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public Object createClusterCustomObject(
      String group, String version, String plural, Object body, String pretty) throws ApiException {
    ApiResponse<Object> resp =
        createClusterCustomObjectWithHttpInfo(group, version, plural, body, pretty);
    return resp.getData();
  }

  /**
   * Creates a cluster scoped Custom object
   *
   * @param group The custom resource&#39;s group name (required)
   * @param version The custom resource&#39;s version (required)
   * @param plural The custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param body The JSON schema of the Resource to create. (required)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return ApiResponse&lt;Object&gt;
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public ApiResponse<Object> createClusterCustomObjectWithHttpInfo(
      String group, String version, String plural, Object body, String pretty) throws ApiException {
    Call call =
        createClusterCustomObjectValidateBeforeCall(
            group, version, plural, body, pretty, null, null);
    Type localVarReturnType = new TypeToken<Object>() {}.getType();
    return apiClient.execute(call, localVarReturnType);
  }

  /**
   * (asynchronously) Creates a cluster scoped Custom object
   *
   * @param group The custom resource&#39;s group name (required)
   * @param version The custom resource&#39;s version (required)
   * @param plural The custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param body The JSON schema of the Resource to create. (required)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param callback The callback to be executed when the API call finishes
   * @return The request call
   * @throws ApiException If fail to process the API call, e.g. serializing the request body object
   */
  public Call createClusterCustomObjectAsync(
      String group,
      String version,
      String plural,
      Object body,
      String pretty,
      final ApiCallback<Object> callback)
      throws ApiException {

    ProgressResponseBody.ProgressListener progressListener = null;
    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

    if (callback != null) {
      progressListener =
          new ProgressResponseBody.ProgressListener() {
            @Override
            public void update(long bytesRead, long contentLength, boolean done) {
              callback.onDownloadProgress(bytesRead, contentLength, done);
            }
          };

      progressRequestListener =
          new ProgressRequestBody.ProgressRequestListener() {
            @Override
            public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
              callback.onUploadProgress(bytesWritten, contentLength, done);
            }
          };
    }

    Call call =
        createClusterCustomObjectValidateBeforeCall(
            group, version, plural, body, pretty, progressListener, progressRequestListener);
    Type localVarReturnType = new TypeToken<Object>() {}.getType();
    apiClient.executeAsync(call, localVarReturnType, callback);
    return call;
  }
  /**
   * Build call for createNamespacedCustomObject
   *
   * @param group The custom resource&#39;s group name (required)
   * @param version The custom resource&#39;s version (required)
   * @param namespace The custom resource&#39;s namespace (required)
   * @param plural The custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param body The JSON schema of the Resource to create. (required)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param progressListener Progress listener
   * @param progressRequestListener Progress request listener
   * @return Call to execute
   * @throws ApiException If fail to serialize the request body object
   */
  public Call createNamespacedCustomObjectCall(
      String group,
      String version,
      String namespace,
      String plural,
      Object body,
      String pretty,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {
    Object localVarPostBody = body;

    // create path and map variables
    String localVarPath =
        "/apis/{group}/{version}/namespaces/{namespace}/{plural}"
            .replaceAll("\\{" + "group" + "\\}", apiClient.escapeString(group.toString()))
            .replaceAll("\\{" + "version" + "\\}", apiClient.escapeString(version.toString()))
            .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(namespace.toString()))
            .replaceAll("\\{" + "plural" + "\\}", apiClient.escapeString(plural.toString()));

    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    if (pretty != null) localVarQueryParams.addAll(apiClient.parameterToPair("pretty", pretty));

    Map<String, String> localVarHeaderParams = new HashMap<String, String>();

    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    final String[] localVarAccepts = {"application/json"};
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
    if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

    final String[] localVarContentTypes = {};

    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
    localVarHeaderParams.put("Content-Type", localVarContentType);

    if (progressListener != null) {
      apiClient
          .getHttpClient()
          .networkInterceptors()
          .add(
              new Interceptor() {
                @Override
                public Response intercept(Interceptor.Chain chain) throws IOException {
                  Response originalResponse = chain.proceed(chain.request());
                  return originalResponse
                      .newBuilder()
                      .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                      .build();
                }
              });
    }

    String[] localVarAuthNames = new String[] {"BearerToken"};
    return apiClient.buildCall(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarFormParams,
        localVarAuthNames,
        progressRequestListener);
  }

  @SuppressWarnings("rawtypes")
  private Call createNamespacedCustomObjectValidateBeforeCall(
      String group,
      String version,
      String namespace,
      String plural,
      Object body,
      String pretty,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {

    // verify the required parameter 'group' is set
    if (group == null) {
      throw new ApiException(
          "Missing the required parameter 'group' when calling createNamespacedCustomObject(Async)");
    }

    // verify the required parameter 'version' is set
    if (version == null) {
      throw new ApiException(
          "Missing the required parameter 'version' when calling createNamespacedCustomObject(Async)");
    }

    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(
          "Missing the required parameter 'namespace' when calling createNamespacedCustomObject(Async)");
    }

    // verify the required parameter 'plural' is set
    if (plural == null) {
      throw new ApiException(
          "Missing the required parameter 'plural' when calling createNamespacedCustomObject(Async)");
    }

    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(
          "Missing the required parameter 'body' when calling createNamespacedCustomObject(Async)");
    }

    Call call =
        createNamespacedCustomObjectCall(
            group,
            version,
            namespace,
            plural,
            body,
            pretty,
            progressListener,
            progressRequestListener);
    return call;
  }

  /**
   * Creates a namespace scoped Custom object
   *
   * @param group The custom resource&#39;s group name (required)
   * @param version The custom resource&#39;s version (required)
   * @param namespace The custom resource&#39;s namespace (required)
   * @param plural The custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param body The JSON schema of the Resource to create. (required)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return Object
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public Object createNamespacedCustomObject(
      String group, String version, String namespace, String plural, Object body, String pretty)
      throws ApiException {
    ApiResponse<Object> resp =
        createNamespacedCustomObjectWithHttpInfo(group, version, namespace, plural, body, pretty);
    return resp.getData();
  }

  /**
   * Creates a namespace scoped Custom object
   *
   * @param group The custom resource&#39;s group name (required)
   * @param version The custom resource&#39;s version (required)
   * @param namespace The custom resource&#39;s namespace (required)
   * @param plural The custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param body The JSON schema of the Resource to create. (required)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return ApiResponse&lt;Object&gt;
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public ApiResponse<Object> createNamespacedCustomObjectWithHttpInfo(
      String group, String version, String namespace, String plural, Object body, String pretty)
      throws ApiException {
    Call call =
        createNamespacedCustomObjectValidateBeforeCall(
            group, version, namespace, plural, body, pretty, null, null);
    Type localVarReturnType = new TypeToken<Object>() {}.getType();
    return apiClient.execute(call, localVarReturnType);
  }

  /**
   * (asynchronously) Creates a namespace scoped Custom object
   *
   * @param group The custom resource&#39;s group name (required)
   * @param version The custom resource&#39;s version (required)
   * @param namespace The custom resource&#39;s namespace (required)
   * @param plural The custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param body The JSON schema of the Resource to create. (required)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param callback The callback to be executed when the API call finishes
   * @return The request call
   * @throws ApiException If fail to process the API call, e.g. serializing the request body object
   */
  public Call createNamespacedCustomObjectAsync(
      String group,
      String version,
      String namespace,
      String plural,
      Object body,
      String pretty,
      final ApiCallback<Object> callback)
      throws ApiException {

    ProgressResponseBody.ProgressListener progressListener = null;
    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

    if (callback != null) {
      progressListener =
          new ProgressResponseBody.ProgressListener() {
            @Override
            public void update(long bytesRead, long contentLength, boolean done) {
              callback.onDownloadProgress(bytesRead, contentLength, done);
            }
          };

      progressRequestListener =
          new ProgressRequestBody.ProgressRequestListener() {
            @Override
            public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
              callback.onUploadProgress(bytesWritten, contentLength, done);
            }
          };
    }

    Call call =
        createNamespacedCustomObjectValidateBeforeCall(
            group,
            version,
            namespace,
            plural,
            body,
            pretty,
            progressListener,
            progressRequestListener);
    Type localVarReturnType = new TypeToken<Object>() {}.getType();
    apiClient.executeAsync(call, localVarReturnType, callback);
    return call;
  }
  /**
   * Build call for deleteClusterCustomObject
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param plural the custom object&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body (required)
   * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value
   *     must be non-negative integer. The value zero indicates delete immediately. If this value is
   *     nil, the default grace period for the specified type will be used. Defaults to a per object
   *     value if not specified. zero means delete immediately. (optional)
   * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be
   *     deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the
   *     \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers
   *     list. Either this field or PropagationPolicy may be set, but not both. (optional)
   * @param propagationPolicy Whether and how garbage collection will be performed. Either this
   *     field or OrphanDependents may be set, but not both. The default policy is decided by the
   *     existing finalizer set in the metadata.finalizers and the resource-specific default policy.
   *     (optional)
   * @param progressListener Progress listener
   * @param progressRequestListener Progress request listener
   * @return Call to execute
   * @throws ApiException If fail to serialize the request body object
   */
  public Call deleteClusterCustomObjectCall(
      String group,
      String version,
      String plural,
      String name,
      V1DeleteOptions body,
      Integer gracePeriodSeconds,
      Boolean orphanDependents,
      String propagationPolicy,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {
    Object localVarPostBody = body;

    // create path and map variables
    String localVarPath =
        "/apis/{group}/{version}/{plural}/{name}"
            .replaceAll("\\{" + "group" + "\\}", apiClient.escapeString(group.toString()))
            .replaceAll("\\{" + "version" + "\\}", apiClient.escapeString(version.toString()))
            .replaceAll("\\{" + "plural" + "\\}", apiClient.escapeString(plural.toString()))
            .replaceAll("\\{" + "name" + "\\}", apiClient.escapeString(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    if (gracePeriodSeconds != null)
      localVarQueryParams.addAll(
          apiClient.parameterToPair("gracePeriodSeconds", gracePeriodSeconds));
    if (orphanDependents != null)
      localVarQueryParams.addAll(apiClient.parameterToPair("orphanDependents", orphanDependents));
    if (propagationPolicy != null)
      localVarQueryParams.addAll(apiClient.parameterToPair("propagationPolicy", propagationPolicy));

    Map<String, String> localVarHeaderParams = new HashMap<String, String>();

    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    final String[] localVarAccepts = {"application/json"};
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
    if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

    final String[] localVarContentTypes = {"*/*"};
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
    localVarHeaderParams.put("Content-Type", localVarContentType);

    if (progressListener != null) {
      apiClient
          .getHttpClient()
          .networkInterceptors()
          .add(
              new Interceptor() {
                @Override
                public Response intercept(Interceptor.Chain chain) throws IOException {
                  Response originalResponse = chain.proceed(chain.request());
                  return originalResponse
                      .newBuilder()
                      .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                      .build();
                }
              });
    }

    String[] localVarAuthNames = new String[] {"BearerToken"};
    return apiClient.buildCall(
        localVarPath,
        "DELETE",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarFormParams,
        localVarAuthNames,
        progressRequestListener);
  }

  @SuppressWarnings("rawtypes")
  private Call deleteClusterCustomObjectValidateBeforeCall(
      String group,
      String version,
      String plural,
      String name,
      V1DeleteOptions body,
      Integer gracePeriodSeconds,
      Boolean orphanDependents,
      String propagationPolicy,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {

    // verify the required parameter 'group' is set
    if (group == null) {
      throw new ApiException(
          "Missing the required parameter 'group' when calling deleteClusterCustomObject(Async)");
    }

    // verify the required parameter 'version' is set
    if (version == null) {
      throw new ApiException(
          "Missing the required parameter 'version' when calling deleteClusterCustomObject(Async)");
    }

    // verify the required parameter 'plural' is set
    if (plural == null) {
      throw new ApiException(
          "Missing the required parameter 'plural' when calling deleteClusterCustomObject(Async)");
    }

    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(
          "Missing the required parameter 'name' when calling deleteClusterCustomObject(Async)");
    }

    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(
          "Missing the required parameter 'body' when calling deleteClusterCustomObject(Async)");
    }

    Call call =
        deleteClusterCustomObjectCall(
            group,
            version,
            plural,
            name,
            body,
            gracePeriodSeconds,
            orphanDependents,
            propagationPolicy,
            progressListener,
            progressRequestListener);
    return call;
  }

  /**
   * Deletes the specified cluster scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param plural the custom object&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body (required)
   * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value
   *     must be non-negative integer. The value zero indicates delete immediately. If this value is
   *     nil, the default grace period for the specified type will be used. Defaults to a per object
   *     value if not specified. zero means delete immediately. (optional)
   * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be
   *     deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the
   *     \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers
   *     list. Either this field or PropagationPolicy may be set, but not both. (optional)
   * @param propagationPolicy Whether and how garbage collection will be performed. Either this
   *     field or OrphanDependents may be set, but not both. The default policy is decided by the
   *     existing finalizer set in the metadata.finalizers and the resource-specific default policy.
   *     (optional)
   * @return Object
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public Object deleteClusterCustomObject(
      String group,
      String version,
      String plural,
      String name,
      V1DeleteOptions body,
      Integer gracePeriodSeconds,
      Boolean orphanDependents,
      String propagationPolicy)
      throws ApiException {
    ApiResponse<Object> resp =
        deleteClusterCustomObjectWithHttpInfo(
            group,
            version,
            plural,
            name,
            body,
            gracePeriodSeconds,
            orphanDependents,
            propagationPolicy);
    return resp.getData();
  }

  /**
   * Deletes the specified cluster scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param plural the custom object&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body (required)
   * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value
   *     must be non-negative integer. The value zero indicates delete immediately. If this value is
   *     nil, the default grace period for the specified type will be used. Defaults to a per object
   *     value if not specified. zero means delete immediately. (optional)
   * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be
   *     deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the
   *     \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers
   *     list. Either this field or PropagationPolicy may be set, but not both. (optional)
   * @param propagationPolicy Whether and how garbage collection will be performed. Either this
   *     field or OrphanDependents may be set, but not both. The default policy is decided by the
   *     existing finalizer set in the metadata.finalizers and the resource-specific default policy.
   *     (optional)
   * @return ApiResponse&lt;Object&gt;
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public ApiResponse<Object> deleteClusterCustomObjectWithHttpInfo(
      String group,
      String version,
      String plural,
      String name,
      V1DeleteOptions body,
      Integer gracePeriodSeconds,
      Boolean orphanDependents,
      String propagationPolicy)
      throws ApiException {
    Call call =
        deleteClusterCustomObjectValidateBeforeCall(
            group,
            version,
            plural,
            name,
            body,
            gracePeriodSeconds,
            orphanDependents,
            propagationPolicy,
            null,
            null);
    Type localVarReturnType = new TypeToken<Object>() {}.getType();
    return apiClient.execute(call, localVarReturnType);
  }

  /**
   * (asynchronously) Deletes the specified cluster scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param plural the custom object&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body (required)
   * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value
   *     must be non-negative integer. The value zero indicates delete immediately. If this value is
   *     nil, the default grace period for the specified type will be used. Defaults to a per object
   *     value if not specified. zero means delete immediately. (optional)
   * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be
   *     deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the
   *     \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers
   *     list. Either this field or PropagationPolicy may be set, but not both. (optional)
   * @param propagationPolicy Whether and how garbage collection will be performed. Either this
   *     field or OrphanDependents may be set, but not both. The default policy is decided by the
   *     existing finalizer set in the metadata.finalizers and the resource-specific default policy.
   *     (optional)
   * @param callback The callback to be executed when the API call finishes
   * @return The request call
   * @throws ApiException If fail to process the API call, e.g. serializing the request body object
   */
  public Call deleteClusterCustomObjectAsync(
      String group,
      String version,
      String plural,
      String name,
      V1DeleteOptions body,
      Integer gracePeriodSeconds,
      Boolean orphanDependents,
      String propagationPolicy,
      final ApiCallback<Object> callback)
      throws ApiException {

    ProgressResponseBody.ProgressListener progressListener = null;
    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

    if (callback != null) {
      progressListener =
          new ProgressResponseBody.ProgressListener() {
            @Override
            public void update(long bytesRead, long contentLength, boolean done) {
              callback.onDownloadProgress(bytesRead, contentLength, done);
            }
          };

      progressRequestListener =
          new ProgressRequestBody.ProgressRequestListener() {
            @Override
            public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
              callback.onUploadProgress(bytesWritten, contentLength, done);
            }
          };
    }

    Call call =
        deleteClusterCustomObjectValidateBeforeCall(
            group,
            version,
            plural,
            name,
            body,
            gracePeriodSeconds,
            orphanDependents,
            propagationPolicy,
            progressListener,
            progressRequestListener);
    Type localVarReturnType = new TypeToken<Object>() {}.getType();
    apiClient.executeAsync(call, localVarReturnType, callback);
    return call;
  }
  /**
   * Build call for deleteNamespacedCustomObject
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param namespace The custom resource&#39;s namespace (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body (required)
   * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value
   *     must be non-negative integer. The value zero indicates delete immediately. If this value is
   *     nil, the default grace period for the specified type will be used. Defaults to a per object
   *     value if not specified. zero means delete immediately. (optional)
   * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be
   *     deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the
   *     \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers
   *     list. Either this field or PropagationPolicy may be set, but not both. (optional)
   * @param propagationPolicy Whether and how garbage collection will be performed. Either this
   *     field or OrphanDependents may be set, but not both. The default policy is decided by the
   *     existing finalizer set in the metadata.finalizers and the resource-specific default policy.
   *     (optional)
   * @param progressListener Progress listener
   * @param progressRequestListener Progress request listener
   * @return Call to execute
   * @throws ApiException If fail to serialize the request body object
   */
  public Call deleteNamespacedCustomObjectCall(
      String group,
      String version,
      String namespace,
      String plural,
      String name,
      V1DeleteOptions body,
      Integer gracePeriodSeconds,
      Boolean orphanDependents,
      String propagationPolicy,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {
    Object localVarPostBody = body;

    // create path and map variables
    String localVarPath =
        "/apis/{group}/{version}/namespaces/{namespace}/{plural}/{name}"
            .replaceAll("\\{" + "group" + "\\}", apiClient.escapeString(group.toString()))
            .replaceAll("\\{" + "version" + "\\}", apiClient.escapeString(version.toString()))
            .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(namespace.toString()))
            .replaceAll("\\{" + "plural" + "\\}", apiClient.escapeString(plural.toString()))
            .replaceAll("\\{" + "name" + "\\}", apiClient.escapeString(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    if (gracePeriodSeconds != null)
      localVarQueryParams.addAll(
          apiClient.parameterToPair("gracePeriodSeconds", gracePeriodSeconds));
    if (orphanDependents != null)
      localVarQueryParams.addAll(apiClient.parameterToPair("orphanDependents", orphanDependents));
    if (propagationPolicy != null)
      localVarQueryParams.addAll(apiClient.parameterToPair("propagationPolicy", propagationPolicy));

    Map<String, String> localVarHeaderParams = new HashMap<String, String>();

    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    final String[] localVarAccepts = {"application/json"};
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
    if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

    final String[] localVarContentTypes = {"*/*"};
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
    localVarHeaderParams.put("Content-Type", localVarContentType);

    if (progressListener != null) {
      apiClient
          .getHttpClient()
          .networkInterceptors()
          .add(
              new Interceptor() {
                @Override
                public Response intercept(Interceptor.Chain chain) throws IOException {
                  Response originalResponse = chain.proceed(chain.request());
                  return originalResponse
                      .newBuilder()
                      .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                      .build();
                }
              });
    }

    String[] localVarAuthNames = new String[] {"BearerToken"};
    return apiClient.buildCall(
        localVarPath,
        "DELETE",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarFormParams,
        localVarAuthNames,
        progressRequestListener);
  }

  @SuppressWarnings("rawtypes")
  private Call deleteNamespacedCustomObjectValidateBeforeCall(
      String group,
      String version,
      String namespace,
      String plural,
      String name,
      V1DeleteOptions body,
      Integer gracePeriodSeconds,
      Boolean orphanDependents,
      String propagationPolicy,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {

    // verify the required parameter 'group' is set
    if (group == null) {
      throw new ApiException(
          "Missing the required parameter 'group' when calling deleteNamespacedCustomObject(Async)");
    }

    // verify the required parameter 'version' is set
    if (version == null) {
      throw new ApiException(
          "Missing the required parameter 'version' when calling deleteNamespacedCustomObject(Async)");
    }

    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(
          "Missing the required parameter 'namespace' when calling deleteNamespacedCustomObject(Async)");
    }

    // verify the required parameter 'plural' is set
    if (plural == null) {
      throw new ApiException(
          "Missing the required parameter 'plural' when calling deleteNamespacedCustomObject(Async)");
    }

    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(
          "Missing the required parameter 'name' when calling deleteNamespacedCustomObject(Async)");
    }

    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(
          "Missing the required parameter 'body' when calling deleteNamespacedCustomObject(Async)");
    }

    Call call =
        deleteNamespacedCustomObjectCall(
            group,
            version,
            namespace,
            plural,
            name,
            body,
            gracePeriodSeconds,
            orphanDependents,
            propagationPolicy,
            progressListener,
            progressRequestListener);
    return call;
  }

  /**
   * Deletes the specified namespace scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param namespace The custom resource&#39;s namespace (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body (required)
   * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value
   *     must be non-negative integer. The value zero indicates delete immediately. If this value is
   *     nil, the default grace period for the specified type will be used. Defaults to a per object
   *     value if not specified. zero means delete immediately. (optional)
   * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be
   *     deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the
   *     \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers
   *     list. Either this field or PropagationPolicy may be set, but not both. (optional)
   * @param propagationPolicy Whether and how garbage collection will be performed. Either this
   *     field or OrphanDependents may be set, but not both. The default policy is decided by the
   *     existing finalizer set in the metadata.finalizers and the resource-specific default policy.
   *     (optional)
   * @return Object
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public Object deleteNamespacedCustomObject(
      String group,
      String version,
      String namespace,
      String plural,
      String name,
      V1DeleteOptions body,
      Integer gracePeriodSeconds,
      Boolean orphanDependents,
      String propagationPolicy)
      throws ApiException {
    ApiResponse<Object> resp =
        deleteNamespacedCustomObjectWithHttpInfo(
            group,
            version,
            namespace,
            plural,
            name,
            body,
            gracePeriodSeconds,
            orphanDependents,
            propagationPolicy);
    return resp.getData();
  }

  /**
   * Deletes the specified namespace scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param namespace The custom resource&#39;s namespace (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body (required)
   * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value
   *     must be non-negative integer. The value zero indicates delete immediately. If this value is
   *     nil, the default grace period for the specified type will be used. Defaults to a per object
   *     value if not specified. zero means delete immediately. (optional)
   * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be
   *     deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the
   *     \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers
   *     list. Either this field or PropagationPolicy may be set, but not both. (optional)
   * @param propagationPolicy Whether and how garbage collection will be performed. Either this
   *     field or OrphanDependents may be set, but not both. The default policy is decided by the
   *     existing finalizer set in the metadata.finalizers and the resource-specific default policy.
   *     (optional)
   * @return ApiResponse&lt;Object&gt;
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public ApiResponse<Object> deleteNamespacedCustomObjectWithHttpInfo(
      String group,
      String version,
      String namespace,
      String plural,
      String name,
      V1DeleteOptions body,
      Integer gracePeriodSeconds,
      Boolean orphanDependents,
      String propagationPolicy)
      throws ApiException {
    Call call =
        deleteNamespacedCustomObjectValidateBeforeCall(
            group,
            version,
            namespace,
            plural,
            name,
            body,
            gracePeriodSeconds,
            orphanDependents,
            propagationPolicy,
            null,
            null);
    Type localVarReturnType = new TypeToken<Object>() {}.getType();
    return apiClient.execute(call, localVarReturnType);
  }

  /**
   * (asynchronously) Deletes the specified namespace scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param namespace The custom resource&#39;s namespace (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body (required)
   * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value
   *     must be non-negative integer. The value zero indicates delete immediately. If this value is
   *     nil, the default grace period for the specified type will be used. Defaults to a per object
   *     value if not specified. zero means delete immediately. (optional)
   * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be
   *     deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the
   *     \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers
   *     list. Either this field or PropagationPolicy may be set, but not both. (optional)
   * @param propagationPolicy Whether and how garbage collection will be performed. Either this
   *     field or OrphanDependents may be set, but not both. The default policy is decided by the
   *     existing finalizer set in the metadata.finalizers and the resource-specific default policy.
   *     (optional)
   * @param callback The callback to be executed when the API call finishes
   * @return The request call
   * @throws ApiException If fail to process the API call, e.g. serializing the request body object
   */
  public Call deleteNamespacedCustomObjectAsync(
      String group,
      String version,
      String namespace,
      String plural,
      String name,
      V1DeleteOptions body,
      Integer gracePeriodSeconds,
      Boolean orphanDependents,
      String propagationPolicy,
      final ApiCallback<Object> callback)
      throws ApiException {

    ProgressResponseBody.ProgressListener progressListener = null;
    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

    if (callback != null) {
      progressListener =
          new ProgressResponseBody.ProgressListener() {
            @Override
            public void update(long bytesRead, long contentLength, boolean done) {
              callback.onDownloadProgress(bytesRead, contentLength, done);
            }
          };

      progressRequestListener =
          new ProgressRequestBody.ProgressRequestListener() {
            @Override
            public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
              callback.onUploadProgress(bytesWritten, contentLength, done);
            }
          };
    }

    Call call =
        deleteNamespacedCustomObjectValidateBeforeCall(
            group,
            version,
            namespace,
            plural,
            name,
            body,
            gracePeriodSeconds,
            orphanDependents,
            propagationPolicy,
            progressListener,
            progressRequestListener);
    Type localVarReturnType = new TypeToken<Object>() {}.getType();
    apiClient.executeAsync(call, localVarReturnType, callback);
    return call;
  }
  /**
   * Build call for getClusterCustomObject
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param plural the custom object&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param progressListener Progress listener
   * @param progressRequestListener Progress request listener
   * @return Call to execute
   * @throws ApiException If fail to serialize the request body object
   */
  public Call getClusterCustomObjectCall(
      String group,
      String version,
      String plural,
      String name,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {
    Object localVarPostBody = null;

    // create path and map variables
    String localVarPath =
        "/apis/{group}/{version}/{plural}/{name}"
            .replaceAll("\\{" + "group" + "\\}", apiClient.escapeString(group.toString()))
            .replaceAll("\\{" + "version" + "\\}", apiClient.escapeString(version.toString()))
            .replaceAll("\\{" + "plural" + "\\}", apiClient.escapeString(plural.toString()))
            .replaceAll("\\{" + "name" + "\\}", apiClient.escapeString(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

    Map<String, String> localVarHeaderParams = new HashMap<String, String>();

    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    final String[] localVarAccepts = {"application/json"};
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
    if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

    final String[] localVarContentTypes = {"*/*"};
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
    localVarHeaderParams.put("Content-Type", localVarContentType);

    if (progressListener != null) {
      apiClient
          .getHttpClient()
          .networkInterceptors()
          .add(
              new Interceptor() {
                @Override
                public Response intercept(Interceptor.Chain chain) throws IOException {
                  Response originalResponse = chain.proceed(chain.request());
                  return originalResponse
                      .newBuilder()
                      .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                      .build();
                }
              });
    }

    String[] localVarAuthNames = new String[] {"BearerToken"};
    return apiClient.buildCall(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarFormParams,
        localVarAuthNames,
        progressRequestListener);
  }

  @SuppressWarnings("rawtypes")
  private Call getClusterCustomObjectValidateBeforeCall(
      String group,
      String version,
      String plural,
      String name,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {

    // verify the required parameter 'group' is set
    if (group == null) {
      throw new ApiException(
          "Missing the required parameter 'group' when calling getClusterCustomObject(Async)");
    }

    // verify the required parameter 'version' is set
    if (version == null) {
      throw new ApiException(
          "Missing the required parameter 'version' when calling getClusterCustomObject(Async)");
    }

    // verify the required parameter 'plural' is set
    if (plural == null) {
      throw new ApiException(
          "Missing the required parameter 'plural' when calling getClusterCustomObject(Async)");
    }

    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(
          "Missing the required parameter 'name' when calling getClusterCustomObject(Async)");
    }

    Call call =
        getClusterCustomObjectCall(
            group, version, plural, name, progressListener, progressRequestListener);
    return call;
  }

  /**
   * Returns a cluster scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param plural the custom object&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @return Object
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public Object getClusterCustomObject(String group, String version, String plural, String name)
      throws ApiException {
    ApiResponse<Object> resp = getClusterCustomObjectWithHttpInfo(group, version, plural, name);
    return resp.getData();
  }

  /**
   * Returns a cluster scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param plural the custom object&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @return ApiResponse&lt;Object&gt;
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public ApiResponse<Object> getClusterCustomObjectWithHttpInfo(
      String group, String version, String plural, String name) throws ApiException {
    Call call = getClusterCustomObjectValidateBeforeCall(group, version, plural, name, null, null);
    Type localVarReturnType = new TypeToken<Object>() {}.getType();
    return apiClient.execute(call, localVarReturnType);
  }

  /**
   * (asynchronously) Returns a cluster scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param plural the custom object&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param callback The callback to be executed when the API call finishes
   * @return The request call
   * @throws ApiException If fail to process the API call, e.g. serializing the request body object
   */
  public Call getClusterCustomObjectAsync(
      String group, String version, String plural, String name, final ApiCallback<Object> callback)
      throws ApiException {

    ProgressResponseBody.ProgressListener progressListener = null;
    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

    if (callback != null) {
      progressListener =
          new ProgressResponseBody.ProgressListener() {
            @Override
            public void update(long bytesRead, long contentLength, boolean done) {
              callback.onDownloadProgress(bytesRead, contentLength, done);
            }
          };

      progressRequestListener =
          new ProgressRequestBody.ProgressRequestListener() {
            @Override
            public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
              callback.onUploadProgress(bytesWritten, contentLength, done);
            }
          };
    }

    Call call =
        getClusterCustomObjectValidateBeforeCall(
            group, version, plural, name, progressListener, progressRequestListener);
    Type localVarReturnType = new TypeToken<Object>() {}.getType();
    apiClient.executeAsync(call, localVarReturnType, callback);
    return call;
  }
  /**
   * Build call for getClusterCustomObjectScale
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param progressListener Progress listener
   * @param progressRequestListener Progress request listener
   * @return Call to execute
   * @throws ApiException If fail to serialize the request body object
   */
  public Call getClusterCustomObjectScaleCall(
      String group,
      String version,
      String plural,
      String name,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {
    Object localVarPostBody = null;

    // create path and map variables
    String localVarPath =
        "/apis/{group}/{version}/{plural}/{name}/scale"
            .replaceAll("\\{" + "group" + "\\}", apiClient.escapeString(group.toString()))
            .replaceAll("\\{" + "version" + "\\}", apiClient.escapeString(version.toString()))
            .replaceAll("\\{" + "plural" + "\\}", apiClient.escapeString(plural.toString()))
            .replaceAll("\\{" + "name" + "\\}", apiClient.escapeString(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

    Map<String, String> localVarHeaderParams = new HashMap<String, String>();

    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    final String[] localVarAccepts = {
      "application/json", "application/yaml", "application/vnd.kubernetes.protobuf"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
    if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

    final String[] localVarContentTypes = {"*/*"};
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
    localVarHeaderParams.put("Content-Type", localVarContentType);

    if (progressListener != null) {
      apiClient
          .getHttpClient()
          .networkInterceptors()
          .add(
              new Interceptor() {
                @Override
                public Response intercept(Interceptor.Chain chain) throws IOException {
                  Response originalResponse = chain.proceed(chain.request());
                  return originalResponse
                      .newBuilder()
                      .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                      .build();
                }
              });
    }

    String[] localVarAuthNames = new String[] {"BearerToken"};
    return apiClient.buildCall(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarFormParams,
        localVarAuthNames,
        progressRequestListener);
  }

  @SuppressWarnings("rawtypes")
  private Call getClusterCustomObjectScaleValidateBeforeCall(
      String group,
      String version,
      String plural,
      String name,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {

    // verify the required parameter 'group' is set
    if (group == null) {
      throw new ApiException(
          "Missing the required parameter 'group' when calling getClusterCustomObjectScale(Async)");
    }

    // verify the required parameter 'version' is set
    if (version == null) {
      throw new ApiException(
          "Missing the required parameter 'version' when calling getClusterCustomObjectScale(Async)");
    }

    // verify the required parameter 'plural' is set
    if (plural == null) {
      throw new ApiException(
          "Missing the required parameter 'plural' when calling getClusterCustomObjectScale(Async)");
    }

    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(
          "Missing the required parameter 'name' when calling getClusterCustomObjectScale(Async)");
    }

    Call call =
        getClusterCustomObjectScaleCall(
            group, version, plural, name, progressListener, progressRequestListener);
    return call;
  }

  /**
   * read scale of the specified custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @return Object
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public Object getClusterCustomObjectScale(
      String group, String version, String plural, String name) throws ApiException {
    ApiResponse<Object> resp =
        getClusterCustomObjectScaleWithHttpInfo(group, version, plural, name);
    return resp.getData();
  }

  /**
   * read scale of the specified custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @return ApiResponse&lt;Object&gt;
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public ApiResponse<Object> getClusterCustomObjectScaleWithHttpInfo(
      String group, String version, String plural, String name) throws ApiException {
    Call call =
        getClusterCustomObjectScaleValidateBeforeCall(group, version, plural, name, null, null);
    Type localVarReturnType = new TypeToken<Object>() {}.getType();
    return apiClient.execute(call, localVarReturnType);
  }

  /**
   * (asynchronously) read scale of the specified custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param callback The callback to be executed when the API call finishes
   * @return The request call
   * @throws ApiException If fail to process the API call, e.g. serializing the request body object
   */
  public Call getClusterCustomObjectScaleAsync(
      String group, String version, String plural, String name, final ApiCallback<Object> callback)
      throws ApiException {

    ProgressResponseBody.ProgressListener progressListener = null;
    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

    if (callback != null) {
      progressListener =
          new ProgressResponseBody.ProgressListener() {
            @Override
            public void update(long bytesRead, long contentLength, boolean done) {
              callback.onDownloadProgress(bytesRead, contentLength, done);
            }
          };

      progressRequestListener =
          new ProgressRequestBody.ProgressRequestListener() {
            @Override
            public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
              callback.onUploadProgress(bytesWritten, contentLength, done);
            }
          };
    }

    Call call =
        getClusterCustomObjectScaleValidateBeforeCall(
            group, version, plural, name, progressListener, progressRequestListener);
    Type localVarReturnType = new TypeToken<Object>() {}.getType();
    apiClient.executeAsync(call, localVarReturnType, callback);
    return call;
  }
  /**
   * Build call for getClusterCustomObjectStatus
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param progressListener Progress listener
   * @param progressRequestListener Progress request listener
   * @return Call to execute
   * @throws ApiException If fail to serialize the request body object
   */
  public Call getClusterCustomObjectStatusCall(
      String group,
      String version,
      String plural,
      String name,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {
    Object localVarPostBody = null;

    // create path and map variables
    String localVarPath =
        "/apis/{group}/{version}/{plural}/{name}/status"
            .replaceAll("\\{" + "group" + "\\}", apiClient.escapeString(group.toString()))
            .replaceAll("\\{" + "version" + "\\}", apiClient.escapeString(version.toString()))
            .replaceAll("\\{" + "plural" + "\\}", apiClient.escapeString(plural.toString()))
            .replaceAll("\\{" + "name" + "\\}", apiClient.escapeString(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

    Map<String, String> localVarHeaderParams = new HashMap<String, String>();

    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    final String[] localVarAccepts = {
      "application/json", "application/yaml", "application/vnd.kubernetes.protobuf"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
    if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

    final String[] localVarContentTypes = {"*/*"};
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
    localVarHeaderParams.put("Content-Type", localVarContentType);

    if (progressListener != null) {
      apiClient
          .getHttpClient()
          .networkInterceptors()
          .add(
              new Interceptor() {
                @Override
                public Response intercept(Interceptor.Chain chain) throws IOException {
                  Response originalResponse = chain.proceed(chain.request());
                  return originalResponse
                      .newBuilder()
                      .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                      .build();
                }
              });
    }

    String[] localVarAuthNames = new String[] {"BearerToken"};
    return apiClient.buildCall(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarFormParams,
        localVarAuthNames,
        progressRequestListener);
  }

  @SuppressWarnings("rawtypes")
  private Call getClusterCustomObjectStatusValidateBeforeCall(
      String group,
      String version,
      String plural,
      String name,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {

    // verify the required parameter 'group' is set
    if (group == null) {
      throw new ApiException(
          "Missing the required parameter 'group' when calling getClusterCustomObjectStatus(Async)");
    }

    // verify the required parameter 'version' is set
    if (version == null) {
      throw new ApiException(
          "Missing the required parameter 'version' when calling getClusterCustomObjectStatus(Async)");
    }

    // verify the required parameter 'plural' is set
    if (plural == null) {
      throw new ApiException(
          "Missing the required parameter 'plural' when calling getClusterCustomObjectStatus(Async)");
    }

    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(
          "Missing the required parameter 'name' when calling getClusterCustomObjectStatus(Async)");
    }

    Call call =
        getClusterCustomObjectStatusCall(
            group, version, plural, name, progressListener, progressRequestListener);
    return call;
  }

  /**
   * read status of the specified cluster scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @return Object
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public Object getClusterCustomObjectStatus(
      String group, String version, String plural, String name) throws ApiException {
    ApiResponse<Object> resp =
        getClusterCustomObjectStatusWithHttpInfo(group, version, plural, name);
    return resp.getData();
  }

  /**
   * read status of the specified cluster scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @return ApiResponse&lt;Object&gt;
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public ApiResponse<Object> getClusterCustomObjectStatusWithHttpInfo(
      String group, String version, String plural, String name) throws ApiException {
    Call call =
        getClusterCustomObjectStatusValidateBeforeCall(group, version, plural, name, null, null);
    Type localVarReturnType = new TypeToken<Object>() {}.getType();
    return apiClient.execute(call, localVarReturnType);
  }

  /**
   * (asynchronously) read status of the specified cluster scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param callback The callback to be executed when the API call finishes
   * @return The request call
   * @throws ApiException If fail to process the API call, e.g. serializing the request body object
   */
  public Call getClusterCustomObjectStatusAsync(
      String group, String version, String plural, String name, final ApiCallback<Object> callback)
      throws ApiException {

    ProgressResponseBody.ProgressListener progressListener = null;
    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

    if (callback != null) {
      progressListener =
          new ProgressResponseBody.ProgressListener() {
            @Override
            public void update(long bytesRead, long contentLength, boolean done) {
              callback.onDownloadProgress(bytesRead, contentLength, done);
            }
          };

      progressRequestListener =
          new ProgressRequestBody.ProgressRequestListener() {
            @Override
            public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
              callback.onUploadProgress(bytesWritten, contentLength, done);
            }
          };
    }

    Call call =
        getClusterCustomObjectStatusValidateBeforeCall(
            group, version, plural, name, progressListener, progressRequestListener);
    Type localVarReturnType = new TypeToken<Object>() {}.getType();
    apiClient.executeAsync(call, localVarReturnType, callback);
    return call;
  }
  /**
   * Build call for getNamespacedCustomObject
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param namespace The custom resource&#39;s namespace (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param progressListener Progress listener
   * @param progressRequestListener Progress request listener
   * @return Call to execute
   * @throws ApiException If fail to serialize the request body object
   */
  public Call getNamespacedCustomObjectCall(
      String group,
      String version,
      String namespace,
      String plural,
      String name,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {
    Object localVarPostBody = null;

    // create path and map variables
    String localVarPath =
        "/apis/{group}/{version}/namespaces/{namespace}/{plural}/{name}"
            .replaceAll("\\{" + "group" + "\\}", apiClient.escapeString(group.toString()))
            .replaceAll("\\{" + "version" + "\\}", apiClient.escapeString(version.toString()))
            .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(namespace.toString()))
            .replaceAll("\\{" + "plural" + "\\}", apiClient.escapeString(plural.toString()))
            .replaceAll("\\{" + "name" + "\\}", apiClient.escapeString(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

    Map<String, String> localVarHeaderParams = new HashMap<String, String>();

    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    final String[] localVarAccepts = {"application/json"};
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
    if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

    final String[] localVarContentTypes = {"*/*"};
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
    localVarHeaderParams.put("Content-Type", localVarContentType);

    if (progressListener != null) {
      apiClient
          .getHttpClient()
          .networkInterceptors()
          .add(
              new Interceptor() {
                @Override
                public Response intercept(Interceptor.Chain chain) throws IOException {
                  Response originalResponse = chain.proceed(chain.request());
                  return originalResponse
                      .newBuilder()
                      .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                      .build();
                }
              });
    }

    String[] localVarAuthNames = new String[] {"BearerToken"};
    return apiClient.buildCall(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarFormParams,
        localVarAuthNames,
        progressRequestListener);
  }

  @SuppressWarnings("rawtypes")
  private Call getNamespacedCustomObjectValidateBeforeCall(
      String group,
      String version,
      String namespace,
      String plural,
      String name,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {

    // verify the required parameter 'group' is set
    if (group == null) {
      throw new ApiException(
          "Missing the required parameter 'group' when calling getNamespacedCustomObject(Async)");
    }

    // verify the required parameter 'version' is set
    if (version == null) {
      throw new ApiException(
          "Missing the required parameter 'version' when calling getNamespacedCustomObject(Async)");
    }

    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(
          "Missing the required parameter 'namespace' when calling getNamespacedCustomObject(Async)");
    }

    // verify the required parameter 'plural' is set
    if (plural == null) {
      throw new ApiException(
          "Missing the required parameter 'plural' when calling getNamespacedCustomObject(Async)");
    }

    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(
          "Missing the required parameter 'name' when calling getNamespacedCustomObject(Async)");
    }

    Call call =
        getNamespacedCustomObjectCall(
            group, version, namespace, plural, name, progressListener, progressRequestListener);
    return call;
  }

  /**
   * Returns a namespace scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param namespace The custom resource&#39;s namespace (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @return Object
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public Object getNamespacedCustomObject(
      String group, String version, String namespace, String plural, String name)
      throws ApiException {
    ApiResponse<Object> resp =
        getNamespacedCustomObjectWithHttpInfo(group, version, namespace, plural, name);
    return resp.getData();
  }

  /**
   * Returns a namespace scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param namespace The custom resource&#39;s namespace (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @return ApiResponse&lt;Object&gt;
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public ApiResponse<Object> getNamespacedCustomObjectWithHttpInfo(
      String group, String version, String namespace, String plural, String name)
      throws ApiException {
    Call call =
        getNamespacedCustomObjectValidateBeforeCall(
            group, version, namespace, plural, name, null, null);
    Type localVarReturnType = new TypeToken<Object>() {}.getType();
    return apiClient.execute(call, localVarReturnType);
  }

  /**
   * (asynchronously) Returns a namespace scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param namespace The custom resource&#39;s namespace (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param callback The callback to be executed when the API call finishes
   * @return The request call
   * @throws ApiException If fail to process the API call, e.g. serializing the request body object
   */
  public Call getNamespacedCustomObjectAsync(
      String group,
      String version,
      String namespace,
      String plural,
      String name,
      final ApiCallback<Object> callback)
      throws ApiException {

    ProgressResponseBody.ProgressListener progressListener = null;
    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

    if (callback != null) {
      progressListener =
          new ProgressResponseBody.ProgressListener() {
            @Override
            public void update(long bytesRead, long contentLength, boolean done) {
              callback.onDownloadProgress(bytesRead, contentLength, done);
            }
          };

      progressRequestListener =
          new ProgressRequestBody.ProgressRequestListener() {
            @Override
            public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
              callback.onUploadProgress(bytesWritten, contentLength, done);
            }
          };
    }

    Call call =
        getNamespacedCustomObjectValidateBeforeCall(
            group, version, namespace, plural, name, progressListener, progressRequestListener);
    Type localVarReturnType = new TypeToken<Object>() {}.getType();
    apiClient.executeAsync(call, localVarReturnType, callback);
    return call;
  }
  /**
   * Build call for getNamespacedCustomObjectScale
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param namespace The custom resource&#39;s namespace (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param progressListener Progress listener
   * @param progressRequestListener Progress request listener
   * @return Call to execute
   * @throws ApiException If fail to serialize the request body object
   */
  public Call getNamespacedCustomObjectScaleCall(
      String group,
      String version,
      String namespace,
      String plural,
      String name,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {
    Object localVarPostBody = null;

    // create path and map variables
    String localVarPath =
        "/apis/{group}/{version}/namespaces/{namespace}/{plural}/{name}/scale"
            .replaceAll("\\{" + "group" + "\\}", apiClient.escapeString(group.toString()))
            .replaceAll("\\{" + "version" + "\\}", apiClient.escapeString(version.toString()))
            .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(namespace.toString()))
            .replaceAll("\\{" + "plural" + "\\}", apiClient.escapeString(plural.toString()))
            .replaceAll("\\{" + "name" + "\\}", apiClient.escapeString(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

    Map<String, String> localVarHeaderParams = new HashMap<String, String>();

    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    final String[] localVarAccepts = {
      "application/json", "application/yaml", "application/vnd.kubernetes.protobuf"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
    if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

    final String[] localVarContentTypes = {"*/*"};
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
    localVarHeaderParams.put("Content-Type", localVarContentType);

    if (progressListener != null) {
      apiClient
          .getHttpClient()
          .networkInterceptors()
          .add(
              new Interceptor() {
                @Override
                public Response intercept(Interceptor.Chain chain) throws IOException {
                  Response originalResponse = chain.proceed(chain.request());
                  return originalResponse
                      .newBuilder()
                      .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                      .build();
                }
              });
    }

    String[] localVarAuthNames = new String[] {"BearerToken"};
    return apiClient.buildCall(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarFormParams,
        localVarAuthNames,
        progressRequestListener);
  }

  @SuppressWarnings("rawtypes")
  private Call getNamespacedCustomObjectScaleValidateBeforeCall(
      String group,
      String version,
      String namespace,
      String plural,
      String name,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {

    // verify the required parameter 'group' is set
    if (group == null) {
      throw new ApiException(
          "Missing the required parameter 'group' when calling getNamespacedCustomObjectScale(Async)");
    }

    // verify the required parameter 'version' is set
    if (version == null) {
      throw new ApiException(
          "Missing the required parameter 'version' when calling getNamespacedCustomObjectScale(Async)");
    }

    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(
          "Missing the required parameter 'namespace' when calling getNamespacedCustomObjectScale(Async)");
    }

    // verify the required parameter 'plural' is set
    if (plural == null) {
      throw new ApiException(
          "Missing the required parameter 'plural' when calling getNamespacedCustomObjectScale(Async)");
    }

    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(
          "Missing the required parameter 'name' when calling getNamespacedCustomObjectScale(Async)");
    }

    Call call =
        getNamespacedCustomObjectScaleCall(
            group, version, namespace, plural, name, progressListener, progressRequestListener);
    return call;
  }

  /**
   * read scale of the specified namespace scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param namespace The custom resource&#39;s namespace (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @return Object
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public Object getNamespacedCustomObjectScale(
      String group, String version, String namespace, String plural, String name)
      throws ApiException {
    ApiResponse<Object> resp =
        getNamespacedCustomObjectScaleWithHttpInfo(group, version, namespace, plural, name);
    return resp.getData();
  }

  /**
   * read scale of the specified namespace scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param namespace The custom resource&#39;s namespace (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @return ApiResponse&lt;Object&gt;
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public ApiResponse<Object> getNamespacedCustomObjectScaleWithHttpInfo(
      String group, String version, String namespace, String plural, String name)
      throws ApiException {
    Call call =
        getNamespacedCustomObjectScaleValidateBeforeCall(
            group, version, namespace, plural, name, null, null);
    Type localVarReturnType = new TypeToken<Object>() {}.getType();
    return apiClient.execute(call, localVarReturnType);
  }

  /**
   * (asynchronously) read scale of the specified namespace scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param namespace The custom resource&#39;s namespace (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param callback The callback to be executed when the API call finishes
   * @return The request call
   * @throws ApiException If fail to process the API call, e.g. serializing the request body object
   */
  public Call getNamespacedCustomObjectScaleAsync(
      String group,
      String version,
      String namespace,
      String plural,
      String name,
      final ApiCallback<Object> callback)
      throws ApiException {

    ProgressResponseBody.ProgressListener progressListener = null;
    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

    if (callback != null) {
      progressListener =
          new ProgressResponseBody.ProgressListener() {
            @Override
            public void update(long bytesRead, long contentLength, boolean done) {
              callback.onDownloadProgress(bytesRead, contentLength, done);
            }
          };

      progressRequestListener =
          new ProgressRequestBody.ProgressRequestListener() {
            @Override
            public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
              callback.onUploadProgress(bytesWritten, contentLength, done);
            }
          };
    }

    Call call =
        getNamespacedCustomObjectScaleValidateBeforeCall(
            group, version, namespace, plural, name, progressListener, progressRequestListener);
    Type localVarReturnType = new TypeToken<Object>() {}.getType();
    apiClient.executeAsync(call, localVarReturnType, callback);
    return call;
  }
  /**
   * Build call for getNamespacedCustomObjectStatus
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param namespace The custom resource&#39;s namespace (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param progressListener Progress listener
   * @param progressRequestListener Progress request listener
   * @return Call to execute
   * @throws ApiException If fail to serialize the request body object
   */
  public Call getNamespacedCustomObjectStatusCall(
      String group,
      String version,
      String namespace,
      String plural,
      String name,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {
    Object localVarPostBody = null;

    // create path and map variables
    String localVarPath =
        "/apis/{group}/{version}/namespaces/{namespace}/{plural}/{name}/status"
            .replaceAll("\\{" + "group" + "\\}", apiClient.escapeString(group.toString()))
            .replaceAll("\\{" + "version" + "\\}", apiClient.escapeString(version.toString()))
            .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(namespace.toString()))
            .replaceAll("\\{" + "plural" + "\\}", apiClient.escapeString(plural.toString()))
            .replaceAll("\\{" + "name" + "\\}", apiClient.escapeString(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

    Map<String, String> localVarHeaderParams = new HashMap<String, String>();

    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    final String[] localVarAccepts = {
      "application/json", "application/yaml", "application/vnd.kubernetes.protobuf"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
    if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

    final String[] localVarContentTypes = {"*/*"};
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
    localVarHeaderParams.put("Content-Type", localVarContentType);

    if (progressListener != null) {
      apiClient
          .getHttpClient()
          .networkInterceptors()
          .add(
              new Interceptor() {
                @Override
                public Response intercept(Interceptor.Chain chain) throws IOException {
                  Response originalResponse = chain.proceed(chain.request());
                  return originalResponse
                      .newBuilder()
                      .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                      .build();
                }
              });
    }

    String[] localVarAuthNames = new String[] {"BearerToken"};
    return apiClient.buildCall(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarFormParams,
        localVarAuthNames,
        progressRequestListener);
  }

  @SuppressWarnings("rawtypes")
  private Call getNamespacedCustomObjectStatusValidateBeforeCall(
      String group,
      String version,
      String namespace,
      String plural,
      String name,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {

    // verify the required parameter 'group' is set
    if (group == null) {
      throw new ApiException(
          "Missing the required parameter 'group' when calling getNamespacedCustomObjectStatus(Async)");
    }

    // verify the required parameter 'version' is set
    if (version == null) {
      throw new ApiException(
          "Missing the required parameter 'version' when calling getNamespacedCustomObjectStatus(Async)");
    }

    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(
          "Missing the required parameter 'namespace' when calling getNamespacedCustomObjectStatus(Async)");
    }

    // verify the required parameter 'plural' is set
    if (plural == null) {
      throw new ApiException(
          "Missing the required parameter 'plural' when calling getNamespacedCustomObjectStatus(Async)");
    }

    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(
          "Missing the required parameter 'name' when calling getNamespacedCustomObjectStatus(Async)");
    }

    Call call =
        getNamespacedCustomObjectStatusCall(
            group, version, namespace, plural, name, progressListener, progressRequestListener);
    return call;
  }

  /**
   * read status of the specified namespace scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param namespace The custom resource&#39;s namespace (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @return Object
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public Object getNamespacedCustomObjectStatus(
      String group, String version, String namespace, String plural, String name)
      throws ApiException {
    ApiResponse<Object> resp =
        getNamespacedCustomObjectStatusWithHttpInfo(group, version, namespace, plural, name);
    return resp.getData();
  }

  /**
   * read status of the specified namespace scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param namespace The custom resource&#39;s namespace (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @return ApiResponse&lt;Object&gt;
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public ApiResponse<Object> getNamespacedCustomObjectStatusWithHttpInfo(
      String group, String version, String namespace, String plural, String name)
      throws ApiException {
    Call call =
        getNamespacedCustomObjectStatusValidateBeforeCall(
            group, version, namespace, plural, name, null, null);
    Type localVarReturnType = new TypeToken<Object>() {}.getType();
    return apiClient.execute(call, localVarReturnType);
  }

  /**
   * (asynchronously) read status of the specified namespace scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param namespace The custom resource&#39;s namespace (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param callback The callback to be executed when the API call finishes
   * @return The request call
   * @throws ApiException If fail to process the API call, e.g. serializing the request body object
   */
  public Call getNamespacedCustomObjectStatusAsync(
      String group,
      String version,
      String namespace,
      String plural,
      String name,
      final ApiCallback<Object> callback)
      throws ApiException {

    ProgressResponseBody.ProgressListener progressListener = null;
    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

    if (callback != null) {
      progressListener =
          new ProgressResponseBody.ProgressListener() {
            @Override
            public void update(long bytesRead, long contentLength, boolean done) {
              callback.onDownloadProgress(bytesRead, contentLength, done);
            }
          };

      progressRequestListener =
          new ProgressRequestBody.ProgressRequestListener() {
            @Override
            public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
              callback.onUploadProgress(bytesWritten, contentLength, done);
            }
          };
    }

    Call call =
        getNamespacedCustomObjectStatusValidateBeforeCall(
            group, version, namespace, plural, name, progressListener, progressRequestListener);
    Type localVarReturnType = new TypeToken<Object>() {}.getType();
    apiClient.executeAsync(call, localVarReturnType, callback);
    return call;
  }
  /**
   * Build call for listClusterCustomObject
   *
   * @param group The custom resource&#39;s group name (required)
   * @param version The custom resource&#39;s version (required)
   * @param plural The custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels.
   *     Defaults to everything. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that
   *     particular version of a resource. Defaults to changes from the beginning of history. When
   *     specified for list: - if unset, then the result is returned from remote storage based on
   *     quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache,
   *     no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   *     (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add,
   *     update, and remove notifications. (optional)
   * @param progressListener Progress listener
   * @param progressRequestListener Progress request listener
   * @return Call to execute
   * @throws ApiException If fail to serialize the request body object
   */
  public Call listClusterCustomObjectCall(
      String group,
      String version,
      String plural,
      String pretty,
      String labelSelector,
      String resourceVersion,
      Boolean watch,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {
    Object localVarPostBody = null;

    // create path and map variables
    String localVarPath =
        "/apis/{group}/{version}/{plural}"
            .replaceAll("\\{" + "group" + "\\}", apiClient.escapeString(group.toString()))
            .replaceAll("\\{" + "version" + "\\}", apiClient.escapeString(version.toString()))
            .replaceAll("\\{" + "plural" + "\\}", apiClient.escapeString(plural.toString()));

    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    if (pretty != null) localVarQueryParams.addAll(apiClient.parameterToPair("pretty", pretty));
    if (labelSelector != null)
      localVarQueryParams.addAll(apiClient.parameterToPair("labelSelector", labelSelector));
    if (resourceVersion != null)
      localVarQueryParams.addAll(apiClient.parameterToPair("resourceVersion", resourceVersion));
    if (watch != null) localVarQueryParams.addAll(apiClient.parameterToPair("watch", watch));

    Map<String, String> localVarHeaderParams = new HashMap<String, String>();

    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    final String[] localVarAccepts = {"application/json", "application/json;stream=watch"};
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
    if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

    final String[] localVarContentTypes = {"*/*"};
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
    localVarHeaderParams.put("Content-Type", localVarContentType);

    if (progressListener != null) {
      apiClient
          .getHttpClient()
          .networkInterceptors()
          .add(
              new Interceptor() {
                @Override
                public Response intercept(Interceptor.Chain chain) throws IOException {
                  Response originalResponse = chain.proceed(chain.request());
                  return originalResponse
                      .newBuilder()
                      .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                      .build();
                }
              });
    }

    String[] localVarAuthNames = new String[] {"BearerToken"};
    return apiClient.buildCall(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarFormParams,
        localVarAuthNames,
        progressRequestListener);
  }

  @SuppressWarnings("rawtypes")
  private Call listClusterCustomObjectValidateBeforeCall(
      String group,
      String version,
      String plural,
      String pretty,
      String labelSelector,
      String resourceVersion,
      Boolean watch,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {

    // verify the required parameter 'group' is set
    if (group == null) {
      throw new ApiException(
          "Missing the required parameter 'group' when calling listClusterCustomObject(Async)");
    }

    // verify the required parameter 'version' is set
    if (version == null) {
      throw new ApiException(
          "Missing the required parameter 'version' when calling listClusterCustomObject(Async)");
    }

    // verify the required parameter 'plural' is set
    if (plural == null) {
      throw new ApiException(
          "Missing the required parameter 'plural' when calling listClusterCustomObject(Async)");
    }

    Call call =
        listClusterCustomObjectCall(
            group,
            version,
            plural,
            pretty,
            labelSelector,
            resourceVersion,
            watch,
            progressListener,
            progressRequestListener);
    return call;
  }

  /**
   * list or watch cluster scoped custom objects
   *
   * @param group The custom resource&#39;s group name (required)
   * @param version The custom resource&#39;s version (required)
   * @param plural The custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels.
   *     Defaults to everything. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that
   *     particular version of a resource. Defaults to changes from the beginning of history. When
   *     specified for list: - if unset, then the result is returned from remote storage based on
   *     quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache,
   *     no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   *     (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add,
   *     update, and remove notifications. (optional)
   * @return Object
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public Object listClusterCustomObject(
      String group,
      String version,
      String plural,
      String pretty,
      String labelSelector,
      String resourceVersion,
      Boolean watch)
      throws ApiException {
    ApiResponse<Object> resp =
        listClusterCustomObjectWithHttpInfo(
            group, version, plural, pretty, labelSelector, resourceVersion, watch);
    return resp.getData();
  }

  /**
   * list or watch cluster scoped custom objects
   *
   * @param group The custom resource&#39;s group name (required)
   * @param version The custom resource&#39;s version (required)
   * @param plural The custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels.
   *     Defaults to everything. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that
   *     particular version of a resource. Defaults to changes from the beginning of history. When
   *     specified for list: - if unset, then the result is returned from remote storage based on
   *     quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache,
   *     no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   *     (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add,
   *     update, and remove notifications. (optional)
   * @return ApiResponse&lt;Object&gt;
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public ApiResponse<Object> listClusterCustomObjectWithHttpInfo(
      String group,
      String version,
      String plural,
      String pretty,
      String labelSelector,
      String resourceVersion,
      Boolean watch)
      throws ApiException {
    Call call =
        listClusterCustomObjectValidateBeforeCall(
            group, version, plural, pretty, labelSelector, resourceVersion, watch, null, null);
    Type localVarReturnType = new TypeToken<Object>() {}.getType();
    return apiClient.execute(call, localVarReturnType);
  }

  /**
   * (asynchronously) list or watch cluster scoped custom objects
   *
   * @param group The custom resource&#39;s group name (required)
   * @param version The custom resource&#39;s version (required)
   * @param plural The custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels.
   *     Defaults to everything. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that
   *     particular version of a resource. Defaults to changes from the beginning of history. When
   *     specified for list: - if unset, then the result is returned from remote storage based on
   *     quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache,
   *     no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   *     (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add,
   *     update, and remove notifications. (optional)
   * @param callback The callback to be executed when the API call finishes
   * @return The request call
   * @throws ApiException If fail to process the API call, e.g. serializing the request body object
   */
  public Call listClusterCustomObjectAsync(
      String group,
      String version,
      String plural,
      String pretty,
      String labelSelector,
      String resourceVersion,
      Boolean watch,
      final ApiCallback<Object> callback)
      throws ApiException {

    ProgressResponseBody.ProgressListener progressListener = null;
    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

    if (callback != null) {
      progressListener =
          new ProgressResponseBody.ProgressListener() {
            @Override
            public void update(long bytesRead, long contentLength, boolean done) {
              callback.onDownloadProgress(bytesRead, contentLength, done);
            }
          };

      progressRequestListener =
          new ProgressRequestBody.ProgressRequestListener() {
            @Override
            public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
              callback.onUploadProgress(bytesWritten, contentLength, done);
            }
          };
    }

    Call call =
        listClusterCustomObjectValidateBeforeCall(
            group,
            version,
            plural,
            pretty,
            labelSelector,
            resourceVersion,
            watch,
            progressListener,
            progressRequestListener);
    Type localVarReturnType = new TypeToken<Object>() {}.getType();
    apiClient.executeAsync(call, localVarReturnType, callback);
    return call;
  }
  /**
   * Build call for listNamespacedCustomObject
   *
   * @param group The custom resource&#39;s group name (required)
   * @param version The custom resource&#39;s version (required)
   * @param namespace The custom resource&#39;s namespace (required)
   * @param plural The custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels.
   *     Defaults to everything. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that
   *     particular version of a resource. Defaults to changes from the beginning of history. When
   *     specified for list: - if unset, then the result is returned from remote storage based on
   *     quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache,
   *     no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   *     (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add,
   *     update, and remove notifications. (optional)
   * @param progressListener Progress listener
   * @param progressRequestListener Progress request listener
   * @return Call to execute
   * @throws ApiException If fail to serialize the request body object
   */
  public Call listNamespacedCustomObjectCall(
      String group,
      String version,
      String namespace,
      String plural,
      String pretty,
      String labelSelector,
      String resourceVersion,
      Boolean watch,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {
    Object localVarPostBody = null;

    // create path and map variables
    String localVarPath =
        "/apis/{group}/{version}/namespaces/{namespace}/{plural}"
            .replaceAll("\\{" + "group" + "\\}", apiClient.escapeString(group.toString()))
            .replaceAll("\\{" + "version" + "\\}", apiClient.escapeString(version.toString()))
            .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(namespace.toString()))
            .replaceAll("\\{" + "plural" + "\\}", apiClient.escapeString(plural.toString()));

    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    if (pretty != null) localVarQueryParams.addAll(apiClient.parameterToPair("pretty", pretty));
    if (labelSelector != null)
      localVarQueryParams.addAll(apiClient.parameterToPair("labelSelector", labelSelector));
    if (resourceVersion != null)
      localVarQueryParams.addAll(apiClient.parameterToPair("resourceVersion", resourceVersion));
    if (watch != null) localVarQueryParams.addAll(apiClient.parameterToPair("watch", watch));

    Map<String, String> localVarHeaderParams = new HashMap<String, String>();

    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    final String[] localVarAccepts = {"application/json", "application/json;stream=watch"};
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
    if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

    final String[] localVarContentTypes = {"*/*"};
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
    localVarHeaderParams.put("Content-Type", localVarContentType);

    if (progressListener != null) {
      apiClient
          .getHttpClient()
          .networkInterceptors()
          .add(
              new Interceptor() {
                @Override
                public Response intercept(Interceptor.Chain chain) throws IOException {
                  Response originalResponse = chain.proceed(chain.request());
                  return originalResponse
                      .newBuilder()
                      .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                      .build();
                }
              });
    }

    String[] localVarAuthNames = new String[] {"BearerToken"};
    return apiClient.buildCall(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarFormParams,
        localVarAuthNames,
        progressRequestListener);
  }

  @SuppressWarnings("rawtypes")
  private Call listNamespacedCustomObjectValidateBeforeCall(
      String group,
      String version,
      String namespace,
      String plural,
      String pretty,
      String labelSelector,
      String resourceVersion,
      Boolean watch,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {

    // verify the required parameter 'group' is set
    if (group == null) {
      throw new ApiException(
          "Missing the required parameter 'group' when calling listNamespacedCustomObject(Async)");
    }

    // verify the required parameter 'version' is set
    if (version == null) {
      throw new ApiException(
          "Missing the required parameter 'version' when calling listNamespacedCustomObject(Async)");
    }

    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(
          "Missing the required parameter 'namespace' when calling listNamespacedCustomObject(Async)");
    }

    // verify the required parameter 'plural' is set
    if (plural == null) {
      throw new ApiException(
          "Missing the required parameter 'plural' when calling listNamespacedCustomObject(Async)");
    }

    Call call =
        listNamespacedCustomObjectCall(
            group,
            version,
            namespace,
            plural,
            pretty,
            labelSelector,
            resourceVersion,
            watch,
            progressListener,
            progressRequestListener);
    return call;
  }

  /**
   * list or watch namespace scoped custom objects
   *
   * @param group The custom resource&#39;s group name (required)
   * @param version The custom resource&#39;s version (required)
   * @param namespace The custom resource&#39;s namespace (required)
   * @param plural The custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels.
   *     Defaults to everything. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that
   *     particular version of a resource. Defaults to changes from the beginning of history. When
   *     specified for list: - if unset, then the result is returned from remote storage based on
   *     quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache,
   *     no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   *     (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add,
   *     update, and remove notifications. (optional)
   * @return Object
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public Object listNamespacedCustomObject(
      String group,
      String version,
      String namespace,
      String plural,
      String pretty,
      String labelSelector,
      String resourceVersion,
      Boolean watch)
      throws ApiException {
    ApiResponse<Object> resp =
        listNamespacedCustomObjectWithHttpInfo(
            group, version, namespace, plural, pretty, labelSelector, resourceVersion, watch);
    return resp.getData();
  }

  /**
   * list or watch namespace scoped custom objects
   *
   * @param group The custom resource&#39;s group name (required)
   * @param version The custom resource&#39;s version (required)
   * @param namespace The custom resource&#39;s namespace (required)
   * @param plural The custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels.
   *     Defaults to everything. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that
   *     particular version of a resource. Defaults to changes from the beginning of history. When
   *     specified for list: - if unset, then the result is returned from remote storage based on
   *     quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache,
   *     no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   *     (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add,
   *     update, and remove notifications. (optional)
   * @return ApiResponse&lt;Object&gt;
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public ApiResponse<Object> listNamespacedCustomObjectWithHttpInfo(
      String group,
      String version,
      String namespace,
      String plural,
      String pretty,
      String labelSelector,
      String resourceVersion,
      Boolean watch)
      throws ApiException {
    Call call =
        listNamespacedCustomObjectValidateBeforeCall(
            group,
            version,
            namespace,
            plural,
            pretty,
            labelSelector,
            resourceVersion,
            watch,
            null,
            null);
    Type localVarReturnType = new TypeToken<Object>() {}.getType();
    return apiClient.execute(call, localVarReturnType);
  }

  /**
   * (asynchronously) list or watch namespace scoped custom objects
   *
   * @param group The custom resource&#39;s group name (required)
   * @param version The custom resource&#39;s version (required)
   * @param namespace The custom resource&#39;s namespace (required)
   * @param plural The custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels.
   *     Defaults to everything. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that
   *     particular version of a resource. Defaults to changes from the beginning of history. When
   *     specified for list: - if unset, then the result is returned from remote storage based on
   *     quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache,
   *     no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   *     (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add,
   *     update, and remove notifications. (optional)
   * @param callback The callback to be executed when the API call finishes
   * @return The request call
   * @throws ApiException If fail to process the API call, e.g. serializing the request body object
   */
  public Call listNamespacedCustomObjectAsync(
      String group,
      String version,
      String namespace,
      String plural,
      String pretty,
      String labelSelector,
      String resourceVersion,
      Boolean watch,
      final ApiCallback<Object> callback)
      throws ApiException {

    ProgressResponseBody.ProgressListener progressListener = null;
    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

    if (callback != null) {
      progressListener =
          new ProgressResponseBody.ProgressListener() {
            @Override
            public void update(long bytesRead, long contentLength, boolean done) {
              callback.onDownloadProgress(bytesRead, contentLength, done);
            }
          };

      progressRequestListener =
          new ProgressRequestBody.ProgressRequestListener() {
            @Override
            public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
              callback.onUploadProgress(bytesWritten, contentLength, done);
            }
          };
    }

    Call call =
        listNamespacedCustomObjectValidateBeforeCall(
            group,
            version,
            namespace,
            plural,
            pretty,
            labelSelector,
            resourceVersion,
            watch,
            progressListener,
            progressRequestListener);
    Type localVarReturnType = new TypeToken<Object>() {}.getType();
    apiClient.executeAsync(call, localVarReturnType, callback);
    return call;
  }
  /**
   * Build call for patchClusterCustomObject
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param plural the custom object&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body The JSON schema of the Resource to patch. (required)
   * @param progressListener Progress listener
   * @param progressRequestListener Progress request listener
   * @return Call to execute
   * @throws ApiException If fail to serialize the request body object
   */
  public Call patchClusterCustomObjectCall(
      String group,
      String version,
      String plural,
      String name,
      Object body,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {
    Object localVarPostBody = body;

    // create path and map variables
    String localVarPath =
        "/apis/{group}/{version}/{plural}/{name}"
            .replaceAll("\\{" + "group" + "\\}", apiClient.escapeString(group.toString()))
            .replaceAll("\\{" + "version" + "\\}", apiClient.escapeString(version.toString()))
            .replaceAll("\\{" + "plural" + "\\}", apiClient.escapeString(plural.toString()))
            .replaceAll("\\{" + "name" + "\\}", apiClient.escapeString(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

    Map<String, String> localVarHeaderParams = new HashMap<String, String>();

    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    final String[] localVarAccepts = {"application/json"};
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
    if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

    final String[] localVarContentTypes = {"application/merge-patch+json"};
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
    localVarHeaderParams.put("Content-Type", localVarContentType);

    if (progressListener != null) {
      apiClient
          .getHttpClient()
          .networkInterceptors()
          .add(
              new Interceptor() {
                @Override
                public Response intercept(Interceptor.Chain chain) throws IOException {
                  Response originalResponse = chain.proceed(chain.request());
                  return originalResponse
                      .newBuilder()
                      .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                      .build();
                }
              });
    }

    String[] localVarAuthNames = new String[] {"BearerToken"};
    return apiClient.buildCall(
        localVarPath,
        "PATCH",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarFormParams,
        localVarAuthNames,
        progressRequestListener);
  }

  @SuppressWarnings("rawtypes")
  private Call patchClusterCustomObjectValidateBeforeCall(
      String group,
      String version,
      String plural,
      String name,
      Object body,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {

    // verify the required parameter 'group' is set
    if (group == null) {
      throw new ApiException(
          "Missing the required parameter 'group' when calling patchClusterCustomObject(Async)");
    }

    // verify the required parameter 'version' is set
    if (version == null) {
      throw new ApiException(
          "Missing the required parameter 'version' when calling patchClusterCustomObject(Async)");
    }

    // verify the required parameter 'plural' is set
    if (plural == null) {
      throw new ApiException(
          "Missing the required parameter 'plural' when calling patchClusterCustomObject(Async)");
    }

    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(
          "Missing the required parameter 'name' when calling patchClusterCustomObject(Async)");
    }

    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(
          "Missing the required parameter 'body' when calling patchClusterCustomObject(Async)");
    }

    Call call =
        patchClusterCustomObjectCall(
            group, version, plural, name, body, progressListener, progressRequestListener);
    return call;
  }

  /**
   * patch the specified cluster scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param plural the custom object&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body The JSON schema of the Resource to patch. (required)
   * @return Object
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public Object patchClusterCustomObject(
      String group, String version, String plural, String name, Object body) throws ApiException {
    ApiResponse<Object> resp =
        patchClusterCustomObjectWithHttpInfo(group, version, plural, name, body);
    return resp.getData();
  }

  /**
   * patch the specified cluster scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param plural the custom object&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body The JSON schema of the Resource to patch. (required)
   * @return ApiResponse&lt;Object&gt;
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public ApiResponse<Object> patchClusterCustomObjectWithHttpInfo(
      String group, String version, String plural, String name, Object body) throws ApiException {
    Call call =
        patchClusterCustomObjectValidateBeforeCall(group, version, plural, name, body, null, null);
    Type localVarReturnType = new TypeToken<Object>() {}.getType();
    return apiClient.execute(call, localVarReturnType);
  }

  /**
   * (asynchronously) patch the specified cluster scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param plural the custom object&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body The JSON schema of the Resource to patch. (required)
   * @param callback The callback to be executed when the API call finishes
   * @return The request call
   * @throws ApiException If fail to process the API call, e.g. serializing the request body object
   */
  public Call patchClusterCustomObjectAsync(
      String group,
      String version,
      String plural,
      String name,
      Object body,
      final ApiCallback<Object> callback)
      throws ApiException {

    ProgressResponseBody.ProgressListener progressListener = null;
    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

    if (callback != null) {
      progressListener =
          new ProgressResponseBody.ProgressListener() {
            @Override
            public void update(long bytesRead, long contentLength, boolean done) {
              callback.onDownloadProgress(bytesRead, contentLength, done);
            }
          };

      progressRequestListener =
          new ProgressRequestBody.ProgressRequestListener() {
            @Override
            public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
              callback.onUploadProgress(bytesWritten, contentLength, done);
            }
          };
    }

    Call call =
        patchClusterCustomObjectValidateBeforeCall(
            group, version, plural, name, body, progressListener, progressRequestListener);
    Type localVarReturnType = new TypeToken<Object>() {}.getType();
    apiClient.executeAsync(call, localVarReturnType, callback);
    return call;
  }
  /**
   * Build call for patchClusterCustomObjectScale
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body (required)
   * @param progressListener Progress listener
   * @param progressRequestListener Progress request listener
   * @return Call to execute
   * @throws ApiException If fail to serialize the request body object
   */
  public Call patchClusterCustomObjectScaleCall(
      String group,
      String version,
      String plural,
      String name,
      Object body,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {
    Object localVarPostBody = body;

    // create path and map variables
    String localVarPath =
        "/apis/{group}/{version}/{plural}/{name}/scale"
            .replaceAll("\\{" + "group" + "\\}", apiClient.escapeString(group.toString()))
            .replaceAll("\\{" + "version" + "\\}", apiClient.escapeString(version.toString()))
            .replaceAll("\\{" + "plural" + "\\}", apiClient.escapeString(plural.toString()))
            .replaceAll("\\{" + "name" + "\\}", apiClient.escapeString(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

    Map<String, String> localVarHeaderParams = new HashMap<String, String>();

    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    final String[] localVarAccepts = {
      "application/json", "application/yaml", "application/vnd.kubernetes.protobuf"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
    if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

    final String[] localVarContentTypes = {"application/merge-patch+json"};
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
    localVarHeaderParams.put("Content-Type", localVarContentType);

    if (progressListener != null) {
      apiClient
          .getHttpClient()
          .networkInterceptors()
          .add(
              new Interceptor() {
                @Override
                public Response intercept(Interceptor.Chain chain) throws IOException {
                  Response originalResponse = chain.proceed(chain.request());
                  return originalResponse
                      .newBuilder()
                      .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                      .build();
                }
              });
    }

    String[] localVarAuthNames = new String[] {"BearerToken"};
    return apiClient.buildCall(
        localVarPath,
        "PATCH",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarFormParams,
        localVarAuthNames,
        progressRequestListener);
  }

  @SuppressWarnings("rawtypes")
  private Call patchClusterCustomObjectScaleValidateBeforeCall(
      String group,
      String version,
      String plural,
      String name,
      Object body,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {

    // verify the required parameter 'group' is set
    if (group == null) {
      throw new ApiException(
          "Missing the required parameter 'group' when calling patchClusterCustomObjectScale(Async)");
    }

    // verify the required parameter 'version' is set
    if (version == null) {
      throw new ApiException(
          "Missing the required parameter 'version' when calling patchClusterCustomObjectScale(Async)");
    }

    // verify the required parameter 'plural' is set
    if (plural == null) {
      throw new ApiException(
          "Missing the required parameter 'plural' when calling patchClusterCustomObjectScale(Async)");
    }

    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(
          "Missing the required parameter 'name' when calling patchClusterCustomObjectScale(Async)");
    }

    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(
          "Missing the required parameter 'body' when calling patchClusterCustomObjectScale(Async)");
    }

    Call call =
        patchClusterCustomObjectScaleCall(
            group, version, plural, name, body, progressListener, progressRequestListener);
    return call;
  }

  /**
   * partially update scale of the specified cluster scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body (required)
   * @return Object
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public Object patchClusterCustomObjectScale(
      String group, String version, String plural, String name, Object body) throws ApiException {
    ApiResponse<Object> resp =
        patchClusterCustomObjectScaleWithHttpInfo(group, version, plural, name, body);
    return resp.getData();
  }

  /**
   * partially update scale of the specified cluster scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body (required)
   * @return ApiResponse&lt;Object&gt;
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public ApiResponse<Object> patchClusterCustomObjectScaleWithHttpInfo(
      String group, String version, String plural, String name, Object body) throws ApiException {
    Call call =
        patchClusterCustomObjectScaleValidateBeforeCall(
            group, version, plural, name, body, null, null);
    Type localVarReturnType = new TypeToken<Object>() {}.getType();
    return apiClient.execute(call, localVarReturnType);
  }

  /**
   * (asynchronously) partially update scale of the specified cluster scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body (required)
   * @param callback The callback to be executed when the API call finishes
   * @return The request call
   * @throws ApiException If fail to process the API call, e.g. serializing the request body object
   */
  public Call patchClusterCustomObjectScaleAsync(
      String group,
      String version,
      String plural,
      String name,
      Object body,
      final ApiCallback<Object> callback)
      throws ApiException {

    ProgressResponseBody.ProgressListener progressListener = null;
    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

    if (callback != null) {
      progressListener =
          new ProgressResponseBody.ProgressListener() {
            @Override
            public void update(long bytesRead, long contentLength, boolean done) {
              callback.onDownloadProgress(bytesRead, contentLength, done);
            }
          };

      progressRequestListener =
          new ProgressRequestBody.ProgressRequestListener() {
            @Override
            public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
              callback.onUploadProgress(bytesWritten, contentLength, done);
            }
          };
    }

    Call call =
        patchClusterCustomObjectScaleValidateBeforeCall(
            group, version, plural, name, body, progressListener, progressRequestListener);
    Type localVarReturnType = new TypeToken<Object>() {}.getType();
    apiClient.executeAsync(call, localVarReturnType, callback);
    return call;
  }
  /**
   * Build call for patchClusterCustomObjectStatus
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body (required)
   * @param progressListener Progress listener
   * @param progressRequestListener Progress request listener
   * @return Call to execute
   * @throws ApiException If fail to serialize the request body object
   */
  public Call patchClusterCustomObjectStatusCall(
      String group,
      String version,
      String plural,
      String name,
      Object body,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {
    Object localVarPostBody = body;

    // create path and map variables
    String localVarPath =
        "/apis/{group}/{version}/{plural}/{name}/status"
            .replaceAll("\\{" + "group" + "\\}", apiClient.escapeString(group.toString()))
            .replaceAll("\\{" + "version" + "\\}", apiClient.escapeString(version.toString()))
            .replaceAll("\\{" + "plural" + "\\}", apiClient.escapeString(plural.toString()))
            .replaceAll("\\{" + "name" + "\\}", apiClient.escapeString(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

    Map<String, String> localVarHeaderParams = new HashMap<String, String>();

    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    final String[] localVarAccepts = {
      "application/json", "application/yaml", "application/vnd.kubernetes.protobuf"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
    if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

    final String[] localVarContentTypes = {"application/merge-patch+json"};
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
    localVarHeaderParams.put("Content-Type", localVarContentType);

    if (progressListener != null) {
      apiClient
          .getHttpClient()
          .networkInterceptors()
          .add(
              new Interceptor() {
                @Override
                public Response intercept(Interceptor.Chain chain) throws IOException {
                  Response originalResponse = chain.proceed(chain.request());
                  return originalResponse
                      .newBuilder()
                      .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                      .build();
                }
              });
    }

    String[] localVarAuthNames = new String[] {"BearerToken"};
    return apiClient.buildCall(
        localVarPath,
        "PATCH",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarFormParams,
        localVarAuthNames,
        progressRequestListener);
  }

  @SuppressWarnings("rawtypes")
  private Call patchClusterCustomObjectStatusValidateBeforeCall(
      String group,
      String version,
      String plural,
      String name,
      Object body,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {

    // verify the required parameter 'group' is set
    if (group == null) {
      throw new ApiException(
          "Missing the required parameter 'group' when calling patchClusterCustomObjectStatus(Async)");
    }

    // verify the required parameter 'version' is set
    if (version == null) {
      throw new ApiException(
          "Missing the required parameter 'version' when calling patchClusterCustomObjectStatus(Async)");
    }

    // verify the required parameter 'plural' is set
    if (plural == null) {
      throw new ApiException(
          "Missing the required parameter 'plural' when calling patchClusterCustomObjectStatus(Async)");
    }

    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(
          "Missing the required parameter 'name' when calling patchClusterCustomObjectStatus(Async)");
    }

    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(
          "Missing the required parameter 'body' when calling patchClusterCustomObjectStatus(Async)");
    }

    Call call =
        patchClusterCustomObjectStatusCall(
            group, version, plural, name, body, progressListener, progressRequestListener);
    return call;
  }

  /**
   * partially update status of the specified cluster scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body (required)
   * @return Object
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public Object patchClusterCustomObjectStatus(
      String group, String version, String plural, String name, Object body) throws ApiException {
    ApiResponse<Object> resp =
        patchClusterCustomObjectStatusWithHttpInfo(group, version, plural, name, body);
    return resp.getData();
  }

  /**
   * partially update status of the specified cluster scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body (required)
   * @return ApiResponse&lt;Object&gt;
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public ApiResponse<Object> patchClusterCustomObjectStatusWithHttpInfo(
      String group, String version, String plural, String name, Object body) throws ApiException {
    Call call =
        patchClusterCustomObjectStatusValidateBeforeCall(
            group, version, plural, name, body, null, null);
    Type localVarReturnType = new TypeToken<Object>() {}.getType();
    return apiClient.execute(call, localVarReturnType);
  }

  /**
   * (asynchronously) partially update status of the specified cluster scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body (required)
   * @param callback The callback to be executed when the API call finishes
   * @return The request call
   * @throws ApiException If fail to process the API call, e.g. serializing the request body object
   */
  public Call patchClusterCustomObjectStatusAsync(
      String group,
      String version,
      String plural,
      String name,
      Object body,
      final ApiCallback<Object> callback)
      throws ApiException {

    ProgressResponseBody.ProgressListener progressListener = null;
    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

    if (callback != null) {
      progressListener =
          new ProgressResponseBody.ProgressListener() {
            @Override
            public void update(long bytesRead, long contentLength, boolean done) {
              callback.onDownloadProgress(bytesRead, contentLength, done);
            }
          };

      progressRequestListener =
          new ProgressRequestBody.ProgressRequestListener() {
            @Override
            public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
              callback.onUploadProgress(bytesWritten, contentLength, done);
            }
          };
    }

    Call call =
        patchClusterCustomObjectStatusValidateBeforeCall(
            group, version, plural, name, body, progressListener, progressRequestListener);
    Type localVarReturnType = new TypeToken<Object>() {}.getType();
    apiClient.executeAsync(call, localVarReturnType, callback);
    return call;
  }
  /**
   * Build call for patchNamespacedCustomObject
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param namespace The custom resource&#39;s namespace (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body The JSON schema of the Resource to patch. (required)
   * @param progressListener Progress listener
   * @param progressRequestListener Progress request listener
   * @return Call to execute
   * @throws ApiException If fail to serialize the request body object
   */
  public Call patchNamespacedCustomObjectCall(
      String group,
      String version,
      String namespace,
      String plural,
      String name,
      Object body,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {
    Object localVarPostBody = body;

    // create path and map variables
    String localVarPath =
        "/apis/{group}/{version}/namespaces/{namespace}/{plural}/{name}"
            .replaceAll("\\{" + "group" + "\\}", apiClient.escapeString(group.toString()))
            .replaceAll("\\{" + "version" + "\\}", apiClient.escapeString(version.toString()))
            .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(namespace.toString()))
            .replaceAll("\\{" + "plural" + "\\}", apiClient.escapeString(plural.toString()))
            .replaceAll("\\{" + "name" + "\\}", apiClient.escapeString(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

    Map<String, String> localVarHeaderParams = new HashMap<String, String>();

    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    final String[] localVarAccepts = {"application/json"};
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
    if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

    final String[] localVarContentTypes = {"application/merge-patch+json"};
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
    localVarHeaderParams.put("Content-Type", localVarContentType);

    if (progressListener != null) {
      apiClient
          .getHttpClient()
          .networkInterceptors()
          .add(
              new Interceptor() {
                @Override
                public Response intercept(Interceptor.Chain chain) throws IOException {
                  Response originalResponse = chain.proceed(chain.request());
                  return originalResponse
                      .newBuilder()
                      .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                      .build();
                }
              });
    }

    String[] localVarAuthNames = new String[] {"BearerToken"};
    return apiClient.buildCall(
        localVarPath,
        "PATCH",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarFormParams,
        localVarAuthNames,
        progressRequestListener);
  }

  @SuppressWarnings("rawtypes")
  private Call patchNamespacedCustomObjectValidateBeforeCall(
      String group,
      String version,
      String namespace,
      String plural,
      String name,
      Object body,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {

    // verify the required parameter 'group' is set
    if (group == null) {
      throw new ApiException(
          "Missing the required parameter 'group' when calling patchNamespacedCustomObject(Async)");
    }

    // verify the required parameter 'version' is set
    if (version == null) {
      throw new ApiException(
          "Missing the required parameter 'version' when calling patchNamespacedCustomObject(Async)");
    }

    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(
          "Missing the required parameter 'namespace' when calling patchNamespacedCustomObject(Async)");
    }

    // verify the required parameter 'plural' is set
    if (plural == null) {
      throw new ApiException(
          "Missing the required parameter 'plural' when calling patchNamespacedCustomObject(Async)");
    }

    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(
          "Missing the required parameter 'name' when calling patchNamespacedCustomObject(Async)");
    }

    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(
          "Missing the required parameter 'body' when calling patchNamespacedCustomObject(Async)");
    }

    Call call =
        patchNamespacedCustomObjectCall(
            group,
            version,
            namespace,
            plural,
            name,
            body,
            progressListener,
            progressRequestListener);
    return call;
  }

  /**
   * patch the specified namespace scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param namespace The custom resource&#39;s namespace (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body The JSON schema of the Resource to patch. (required)
   * @return Object
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public Object patchNamespacedCustomObject(
      String group, String version, String namespace, String plural, String name, Object body)
      throws ApiException {
    ApiResponse<Object> resp =
        patchNamespacedCustomObjectWithHttpInfo(group, version, namespace, plural, name, body);
    return resp.getData();
  }

  /**
   * patch the specified namespace scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param namespace The custom resource&#39;s namespace (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body The JSON schema of the Resource to patch. (required)
   * @return ApiResponse&lt;Object&gt;
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public ApiResponse<Object> patchNamespacedCustomObjectWithHttpInfo(
      String group, String version, String namespace, String plural, String name, Object body)
      throws ApiException {
    Call call =
        patchNamespacedCustomObjectValidateBeforeCall(
            group, version, namespace, plural, name, body, null, null);
    Type localVarReturnType = new TypeToken<Object>() {}.getType();
    return apiClient.execute(call, localVarReturnType);
  }

  /**
   * (asynchronously) patch the specified namespace scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param namespace The custom resource&#39;s namespace (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body The JSON schema of the Resource to patch. (required)
   * @param callback The callback to be executed when the API call finishes
   * @return The request call
   * @throws ApiException If fail to process the API call, e.g. serializing the request body object
   */
  public Call patchNamespacedCustomObjectAsync(
      String group,
      String version,
      String namespace,
      String plural,
      String name,
      Object body,
      final ApiCallback<Object> callback)
      throws ApiException {

    ProgressResponseBody.ProgressListener progressListener = null;
    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

    if (callback != null) {
      progressListener =
          new ProgressResponseBody.ProgressListener() {
            @Override
            public void update(long bytesRead, long contentLength, boolean done) {
              callback.onDownloadProgress(bytesRead, contentLength, done);
            }
          };

      progressRequestListener =
          new ProgressRequestBody.ProgressRequestListener() {
            @Override
            public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
              callback.onUploadProgress(bytesWritten, contentLength, done);
            }
          };
    }

    Call call =
        patchNamespacedCustomObjectValidateBeforeCall(
            group,
            version,
            namespace,
            plural,
            name,
            body,
            progressListener,
            progressRequestListener);
    Type localVarReturnType = new TypeToken<Object>() {}.getType();
    apiClient.executeAsync(call, localVarReturnType, callback);
    return call;
  }
  /**
   * Build call for patchNamespacedCustomObjectScale
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param namespace The custom resource&#39;s namespace (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body (required)
   * @param progressListener Progress listener
   * @param progressRequestListener Progress request listener
   * @return Call to execute
   * @throws ApiException If fail to serialize the request body object
   */
  public Call patchNamespacedCustomObjectScaleCall(
      String group,
      String version,
      String namespace,
      String plural,
      String name,
      Object body,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {
    Object localVarPostBody = body;

    // create path and map variables
    String localVarPath =
        "/apis/{group}/{version}/namespaces/{namespace}/{plural}/{name}/scale"
            .replaceAll("\\{" + "group" + "\\}", apiClient.escapeString(group.toString()))
            .replaceAll("\\{" + "version" + "\\}", apiClient.escapeString(version.toString()))
            .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(namespace.toString()))
            .replaceAll("\\{" + "plural" + "\\}", apiClient.escapeString(plural.toString()))
            .replaceAll("\\{" + "name" + "\\}", apiClient.escapeString(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

    Map<String, String> localVarHeaderParams = new HashMap<String, String>();

    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    final String[] localVarAccepts = {
      "application/json", "application/yaml", "application/vnd.kubernetes.protobuf"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
    if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

    final String[] localVarContentTypes = {"application/merge-patch+json"};
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
    localVarHeaderParams.put("Content-Type", localVarContentType);

    if (progressListener != null) {
      apiClient
          .getHttpClient()
          .networkInterceptors()
          .add(
              new Interceptor() {
                @Override
                public Response intercept(Interceptor.Chain chain) throws IOException {
                  Response originalResponse = chain.proceed(chain.request());
                  return originalResponse
                      .newBuilder()
                      .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                      .build();
                }
              });
    }

    String[] localVarAuthNames = new String[] {"BearerToken"};
    return apiClient.buildCall(
        localVarPath,
        "PATCH",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarFormParams,
        localVarAuthNames,
        progressRequestListener);
  }

  @SuppressWarnings("rawtypes")
  private Call patchNamespacedCustomObjectScaleValidateBeforeCall(
      String group,
      String version,
      String namespace,
      String plural,
      String name,
      Object body,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {

    // verify the required parameter 'group' is set
    if (group == null) {
      throw new ApiException(
          "Missing the required parameter 'group' when calling patchNamespacedCustomObjectScale(Async)");
    }

    // verify the required parameter 'version' is set
    if (version == null) {
      throw new ApiException(
          "Missing the required parameter 'version' when calling patchNamespacedCustomObjectScale(Async)");
    }

    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(
          "Missing the required parameter 'namespace' when calling patchNamespacedCustomObjectScale(Async)");
    }

    // verify the required parameter 'plural' is set
    if (plural == null) {
      throw new ApiException(
          "Missing the required parameter 'plural' when calling patchNamespacedCustomObjectScale(Async)");
    }

    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(
          "Missing the required parameter 'name' when calling patchNamespacedCustomObjectScale(Async)");
    }

    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(
          "Missing the required parameter 'body' when calling patchNamespacedCustomObjectScale(Async)");
    }

    Call call =
        patchNamespacedCustomObjectScaleCall(
            group,
            version,
            namespace,
            plural,
            name,
            body,
            progressListener,
            progressRequestListener);
    return call;
  }

  /**
   * partially update scale of the specified namespace scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param namespace The custom resource&#39;s namespace (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body (required)
   * @return Object
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public Object patchNamespacedCustomObjectScale(
      String group, String version, String namespace, String plural, String name, Object body)
      throws ApiException {
    ApiResponse<Object> resp =
        patchNamespacedCustomObjectScaleWithHttpInfo(group, version, namespace, plural, name, body);
    return resp.getData();
  }

  /**
   * partially update scale of the specified namespace scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param namespace The custom resource&#39;s namespace (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body (required)
   * @return ApiResponse&lt;Object&gt;
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public ApiResponse<Object> patchNamespacedCustomObjectScaleWithHttpInfo(
      String group, String version, String namespace, String plural, String name, Object body)
      throws ApiException {
    Call call =
        patchNamespacedCustomObjectScaleValidateBeforeCall(
            group, version, namespace, plural, name, body, null, null);
    Type localVarReturnType = new TypeToken<Object>() {}.getType();
    return apiClient.execute(call, localVarReturnType);
  }

  /**
   * (asynchronously) partially update scale of the specified namespace scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param namespace The custom resource&#39;s namespace (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body (required)
   * @param callback The callback to be executed when the API call finishes
   * @return The request call
   * @throws ApiException If fail to process the API call, e.g. serializing the request body object
   */
  public Call patchNamespacedCustomObjectScaleAsync(
      String group,
      String version,
      String namespace,
      String plural,
      String name,
      Object body,
      final ApiCallback<Object> callback)
      throws ApiException {

    ProgressResponseBody.ProgressListener progressListener = null;
    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

    if (callback != null) {
      progressListener =
          new ProgressResponseBody.ProgressListener() {
            @Override
            public void update(long bytesRead, long contentLength, boolean done) {
              callback.onDownloadProgress(bytesRead, contentLength, done);
            }
          };

      progressRequestListener =
          new ProgressRequestBody.ProgressRequestListener() {
            @Override
            public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
              callback.onUploadProgress(bytesWritten, contentLength, done);
            }
          };
    }

    Call call =
        patchNamespacedCustomObjectScaleValidateBeforeCall(
            group,
            version,
            namespace,
            plural,
            name,
            body,
            progressListener,
            progressRequestListener);
    Type localVarReturnType = new TypeToken<Object>() {}.getType();
    apiClient.executeAsync(call, localVarReturnType, callback);
    return call;
  }
  /**
   * Build call for patchNamespacedCustomObjectStatus
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param namespace The custom resource&#39;s namespace (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body (required)
   * @param progressListener Progress listener
   * @param progressRequestListener Progress request listener
   * @return Call to execute
   * @throws ApiException If fail to serialize the request body object
   */
  public Call patchNamespacedCustomObjectStatusCall(
      String group,
      String version,
      String namespace,
      String plural,
      String name,
      Object body,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {
    Object localVarPostBody = body;

    // create path and map variables
    String localVarPath =
        "/apis/{group}/{version}/namespaces/{namespace}/{plural}/{name}/status"
            .replaceAll("\\{" + "group" + "\\}", apiClient.escapeString(group.toString()))
            .replaceAll("\\{" + "version" + "\\}", apiClient.escapeString(version.toString()))
            .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(namespace.toString()))
            .replaceAll("\\{" + "plural" + "\\}", apiClient.escapeString(plural.toString()))
            .replaceAll("\\{" + "name" + "\\}", apiClient.escapeString(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

    Map<String, String> localVarHeaderParams = new HashMap<String, String>();

    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    final String[] localVarAccepts = {
      "application/json", "application/yaml", "application/vnd.kubernetes.protobuf"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
    if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

    final String[] localVarContentTypes = {"application/merge-patch+json"};
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
    localVarHeaderParams.put("Content-Type", localVarContentType);

    if (progressListener != null) {
      apiClient
          .getHttpClient()
          .networkInterceptors()
          .add(
              new Interceptor() {
                @Override
                public Response intercept(Interceptor.Chain chain) throws IOException {
                  Response originalResponse = chain.proceed(chain.request());
                  return originalResponse
                      .newBuilder()
                      .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                      .build();
                }
              });
    }

    String[] localVarAuthNames = new String[] {"BearerToken"};
    return apiClient.buildCall(
        localVarPath,
        "PATCH",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarFormParams,
        localVarAuthNames,
        progressRequestListener);
  }

  @SuppressWarnings("rawtypes")
  private Call patchNamespacedCustomObjectStatusValidateBeforeCall(
      String group,
      String version,
      String namespace,
      String plural,
      String name,
      Object body,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {

    // verify the required parameter 'group' is set
    if (group == null) {
      throw new ApiException(
          "Missing the required parameter 'group' when calling patchNamespacedCustomObjectStatus(Async)");
    }

    // verify the required parameter 'version' is set
    if (version == null) {
      throw new ApiException(
          "Missing the required parameter 'version' when calling patchNamespacedCustomObjectStatus(Async)");
    }

    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(
          "Missing the required parameter 'namespace' when calling patchNamespacedCustomObjectStatus(Async)");
    }

    // verify the required parameter 'plural' is set
    if (plural == null) {
      throw new ApiException(
          "Missing the required parameter 'plural' when calling patchNamespacedCustomObjectStatus(Async)");
    }

    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(
          "Missing the required parameter 'name' when calling patchNamespacedCustomObjectStatus(Async)");
    }

    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(
          "Missing the required parameter 'body' when calling patchNamespacedCustomObjectStatus(Async)");
    }

    Call call =
        patchNamespacedCustomObjectStatusCall(
            group,
            version,
            namespace,
            plural,
            name,
            body,
            progressListener,
            progressRequestListener);
    return call;
  }

  /**
   * partially update status of the specified namespace scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param namespace The custom resource&#39;s namespace (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body (required)
   * @return Object
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public Object patchNamespacedCustomObjectStatus(
      String group, String version, String namespace, String plural, String name, Object body)
      throws ApiException {
    ApiResponse<Object> resp =
        patchNamespacedCustomObjectStatusWithHttpInfo(
            group, version, namespace, plural, name, body);
    return resp.getData();
  }

  /**
   * partially update status of the specified namespace scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param namespace The custom resource&#39;s namespace (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body (required)
   * @return ApiResponse&lt;Object&gt;
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public ApiResponse<Object> patchNamespacedCustomObjectStatusWithHttpInfo(
      String group, String version, String namespace, String plural, String name, Object body)
      throws ApiException {
    Call call =
        patchNamespacedCustomObjectStatusValidateBeforeCall(
            group, version, namespace, plural, name, body, null, null);
    Type localVarReturnType = new TypeToken<Object>() {}.getType();
    return apiClient.execute(call, localVarReturnType);
  }

  /**
   * (asynchronously) partially update status of the specified namespace scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param namespace The custom resource&#39;s namespace (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body (required)
   * @param callback The callback to be executed when the API call finishes
   * @return The request call
   * @throws ApiException If fail to process the API call, e.g. serializing the request body object
   */
  public Call patchNamespacedCustomObjectStatusAsync(
      String group,
      String version,
      String namespace,
      String plural,
      String name,
      Object body,
      final ApiCallback<Object> callback)
      throws ApiException {

    ProgressResponseBody.ProgressListener progressListener = null;
    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

    if (callback != null) {
      progressListener =
          new ProgressResponseBody.ProgressListener() {
            @Override
            public void update(long bytesRead, long contentLength, boolean done) {
              callback.onDownloadProgress(bytesRead, contentLength, done);
            }
          };

      progressRequestListener =
          new ProgressRequestBody.ProgressRequestListener() {
            @Override
            public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
              callback.onUploadProgress(bytesWritten, contentLength, done);
            }
          };
    }

    Call call =
        patchNamespacedCustomObjectStatusValidateBeforeCall(
            group,
            version,
            namespace,
            plural,
            name,
            body,
            progressListener,
            progressRequestListener);
    Type localVarReturnType = new TypeToken<Object>() {}.getType();
    apiClient.executeAsync(call, localVarReturnType, callback);
    return call;
  }
  /**
   * Build call for replaceClusterCustomObject
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param plural the custom object&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body The JSON schema of the Resource to replace. (required)
   * @param progressListener Progress listener
   * @param progressRequestListener Progress request listener
   * @return Call to execute
   * @throws ApiException If fail to serialize the request body object
   */
  public Call replaceClusterCustomObjectCall(
      String group,
      String version,
      String plural,
      String name,
      Object body,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {
    Object localVarPostBody = body;

    // create path and map variables
    String localVarPath =
        "/apis/{group}/{version}/{plural}/{name}"
            .replaceAll("\\{" + "group" + "\\}", apiClient.escapeString(group.toString()))
            .replaceAll("\\{" + "version" + "\\}", apiClient.escapeString(version.toString()))
            .replaceAll("\\{" + "plural" + "\\}", apiClient.escapeString(plural.toString()))
            .replaceAll("\\{" + "name" + "\\}", apiClient.escapeString(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

    Map<String, String> localVarHeaderParams = new HashMap<String, String>();

    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    final String[] localVarAccepts = {"application/json"};
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
    if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

    final String[] localVarContentTypes = {"*/*"};
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
    localVarHeaderParams.put("Content-Type", localVarContentType);

    if (progressListener != null) {
      apiClient
          .getHttpClient()
          .networkInterceptors()
          .add(
              new Interceptor() {
                @Override
                public Response intercept(Interceptor.Chain chain) throws IOException {
                  Response originalResponse = chain.proceed(chain.request());
                  return originalResponse
                      .newBuilder()
                      .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                      .build();
                }
              });
    }

    String[] localVarAuthNames = new String[] {"BearerToken"};
    return apiClient.buildCall(
        localVarPath,
        "PUT",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarFormParams,
        localVarAuthNames,
        progressRequestListener);
  }

  @SuppressWarnings("rawtypes")
  private Call replaceClusterCustomObjectValidateBeforeCall(
      String group,
      String version,
      String plural,
      String name,
      Object body,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {

    // verify the required parameter 'group' is set
    if (group == null) {
      throw new ApiException(
          "Missing the required parameter 'group' when calling replaceClusterCustomObject(Async)");
    }

    // verify the required parameter 'version' is set
    if (version == null) {
      throw new ApiException(
          "Missing the required parameter 'version' when calling replaceClusterCustomObject(Async)");
    }

    // verify the required parameter 'plural' is set
    if (plural == null) {
      throw new ApiException(
          "Missing the required parameter 'plural' when calling replaceClusterCustomObject(Async)");
    }

    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(
          "Missing the required parameter 'name' when calling replaceClusterCustomObject(Async)");
    }

    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(
          "Missing the required parameter 'body' when calling replaceClusterCustomObject(Async)");
    }

    Call call =
        replaceClusterCustomObjectCall(
            group, version, plural, name, body, progressListener, progressRequestListener);
    return call;
  }

  /**
   * replace the specified cluster scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param plural the custom object&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body The JSON schema of the Resource to replace. (required)
   * @return Object
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public Object replaceClusterCustomObject(
      String group, String version, String plural, String name, Object body) throws ApiException {
    ApiResponse<Object> resp =
        replaceClusterCustomObjectWithHttpInfo(group, version, plural, name, body);
    return resp.getData();
  }

  /**
   * replace the specified cluster scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param plural the custom object&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body The JSON schema of the Resource to replace. (required)
   * @return ApiResponse&lt;Object&gt;
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public ApiResponse<Object> replaceClusterCustomObjectWithHttpInfo(
      String group, String version, String plural, String name, Object body) throws ApiException {
    Call call =
        replaceClusterCustomObjectValidateBeforeCall(
            group, version, plural, name, body, null, null);
    Type localVarReturnType = new TypeToken<Object>() {}.getType();
    return apiClient.execute(call, localVarReturnType);
  }

  /**
   * (asynchronously) replace the specified cluster scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param plural the custom object&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body The JSON schema of the Resource to replace. (required)
   * @param callback The callback to be executed when the API call finishes
   * @return The request call
   * @throws ApiException If fail to process the API call, e.g. serializing the request body object
   */
  public Call replaceClusterCustomObjectAsync(
      String group,
      String version,
      String plural,
      String name,
      Object body,
      final ApiCallback<Object> callback)
      throws ApiException {

    ProgressResponseBody.ProgressListener progressListener = null;
    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

    if (callback != null) {
      progressListener =
          new ProgressResponseBody.ProgressListener() {
            @Override
            public void update(long bytesRead, long contentLength, boolean done) {
              callback.onDownloadProgress(bytesRead, contentLength, done);
            }
          };

      progressRequestListener =
          new ProgressRequestBody.ProgressRequestListener() {
            @Override
            public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
              callback.onUploadProgress(bytesWritten, contentLength, done);
            }
          };
    }

    Call call =
        replaceClusterCustomObjectValidateBeforeCall(
            group, version, plural, name, body, progressListener, progressRequestListener);
    Type localVarReturnType = new TypeToken<Object>() {}.getType();
    apiClient.executeAsync(call, localVarReturnType, callback);
    return call;
  }
  /**
   * Build call for replaceClusterCustomObjectScale
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body (required)
   * @param progressListener Progress listener
   * @param progressRequestListener Progress request listener
   * @return Call to execute
   * @throws ApiException If fail to serialize the request body object
   */
  public Call replaceClusterCustomObjectScaleCall(
      String group,
      String version,
      String plural,
      String name,
      Object body,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {
    Object localVarPostBody = body;

    // create path and map variables
    String localVarPath =
        "/apis/{group}/{version}/{plural}/{name}/scale"
            .replaceAll("\\{" + "group" + "\\}", apiClient.escapeString(group.toString()))
            .replaceAll("\\{" + "version" + "\\}", apiClient.escapeString(version.toString()))
            .replaceAll("\\{" + "plural" + "\\}", apiClient.escapeString(plural.toString()))
            .replaceAll("\\{" + "name" + "\\}", apiClient.escapeString(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

    Map<String, String> localVarHeaderParams = new HashMap<String, String>();

    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    final String[] localVarAccepts = {
      "application/json", "application/yaml", "application/vnd.kubernetes.protobuf"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
    if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

    final String[] localVarContentTypes = {"*/*"};
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
    localVarHeaderParams.put("Content-Type", localVarContentType);

    if (progressListener != null) {
      apiClient
          .getHttpClient()
          .networkInterceptors()
          .add(
              new Interceptor() {
                @Override
                public Response intercept(Interceptor.Chain chain) throws IOException {
                  Response originalResponse = chain.proceed(chain.request());
                  return originalResponse
                      .newBuilder()
                      .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                      .build();
                }
              });
    }

    String[] localVarAuthNames = new String[] {"BearerToken"};
    return apiClient.buildCall(
        localVarPath,
        "PUT",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarFormParams,
        localVarAuthNames,
        progressRequestListener);
  }

  @SuppressWarnings("rawtypes")
  private Call replaceClusterCustomObjectScaleValidateBeforeCall(
      String group,
      String version,
      String plural,
      String name,
      Object body,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {

    // verify the required parameter 'group' is set
    if (group == null) {
      throw new ApiException(
          "Missing the required parameter 'group' when calling replaceClusterCustomObjectScale(Async)");
    }

    // verify the required parameter 'version' is set
    if (version == null) {
      throw new ApiException(
          "Missing the required parameter 'version' when calling replaceClusterCustomObjectScale(Async)");
    }

    // verify the required parameter 'plural' is set
    if (plural == null) {
      throw new ApiException(
          "Missing the required parameter 'plural' when calling replaceClusterCustomObjectScale(Async)");
    }

    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(
          "Missing the required parameter 'name' when calling replaceClusterCustomObjectScale(Async)");
    }

    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(
          "Missing the required parameter 'body' when calling replaceClusterCustomObjectScale(Async)");
    }

    Call call =
        replaceClusterCustomObjectScaleCall(
            group, version, plural, name, body, progressListener, progressRequestListener);
    return call;
  }

  /**
   * replace scale of the specified cluster scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body (required)
   * @return Object
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public Object replaceClusterCustomObjectScale(
      String group, String version, String plural, String name, Object body) throws ApiException {
    ApiResponse<Object> resp =
        replaceClusterCustomObjectScaleWithHttpInfo(group, version, plural, name, body);
    return resp.getData();
  }

  /**
   * replace scale of the specified cluster scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body (required)
   * @return ApiResponse&lt;Object&gt;
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public ApiResponse<Object> replaceClusterCustomObjectScaleWithHttpInfo(
      String group, String version, String plural, String name, Object body) throws ApiException {
    Call call =
        replaceClusterCustomObjectScaleValidateBeforeCall(
            group, version, plural, name, body, null, null);
    Type localVarReturnType = new TypeToken<Object>() {}.getType();
    return apiClient.execute(call, localVarReturnType);
  }

  /**
   * (asynchronously) replace scale of the specified cluster scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body (required)
   * @param callback The callback to be executed when the API call finishes
   * @return The request call
   * @throws ApiException If fail to process the API call, e.g. serializing the request body object
   */
  public Call replaceClusterCustomObjectScaleAsync(
      String group,
      String version,
      String plural,
      String name,
      Object body,
      final ApiCallback<Object> callback)
      throws ApiException {

    ProgressResponseBody.ProgressListener progressListener = null;
    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

    if (callback != null) {
      progressListener =
          new ProgressResponseBody.ProgressListener() {
            @Override
            public void update(long bytesRead, long contentLength, boolean done) {
              callback.onDownloadProgress(bytesRead, contentLength, done);
            }
          };

      progressRequestListener =
          new ProgressRequestBody.ProgressRequestListener() {
            @Override
            public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
              callback.onUploadProgress(bytesWritten, contentLength, done);
            }
          };
    }

    Call call =
        replaceClusterCustomObjectScaleValidateBeforeCall(
            group, version, plural, name, body, progressListener, progressRequestListener);
    Type localVarReturnType = new TypeToken<Object>() {}.getType();
    apiClient.executeAsync(call, localVarReturnType, callback);
    return call;
  }
  /**
   * Build call for replaceClusterCustomObjectStatus
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body (required)
   * @param progressListener Progress listener
   * @param progressRequestListener Progress request listener
   * @return Call to execute
   * @throws ApiException If fail to serialize the request body object
   */
  public Call replaceClusterCustomObjectStatusCall(
      String group,
      String version,
      String plural,
      String name,
      Object body,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {
    Object localVarPostBody = body;

    // create path and map variables
    String localVarPath =
        "/apis/{group}/{version}/{plural}/{name}/status"
            .replaceAll("\\{" + "group" + "\\}", apiClient.escapeString(group.toString()))
            .replaceAll("\\{" + "version" + "\\}", apiClient.escapeString(version.toString()))
            .replaceAll("\\{" + "plural" + "\\}", apiClient.escapeString(plural.toString()))
            .replaceAll("\\{" + "name" + "\\}", apiClient.escapeString(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

    Map<String, String> localVarHeaderParams = new HashMap<String, String>();

    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    final String[] localVarAccepts = {
      "application/json", "application/yaml", "application/vnd.kubernetes.protobuf"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
    if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

    final String[] localVarContentTypes = {"*/*"};
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
    localVarHeaderParams.put("Content-Type", localVarContentType);

    if (progressListener != null) {
      apiClient
          .getHttpClient()
          .networkInterceptors()
          .add(
              new Interceptor() {
                @Override
                public Response intercept(Interceptor.Chain chain) throws IOException {
                  Response originalResponse = chain.proceed(chain.request());
                  return originalResponse
                      .newBuilder()
                      .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                      .build();
                }
              });
    }

    String[] localVarAuthNames = new String[] {"BearerToken"};
    return apiClient.buildCall(
        localVarPath,
        "PUT",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarFormParams,
        localVarAuthNames,
        progressRequestListener);
  }

  @SuppressWarnings("rawtypes")
  private Call replaceClusterCustomObjectStatusValidateBeforeCall(
      String group,
      String version,
      String plural,
      String name,
      Object body,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {

    // verify the required parameter 'group' is set
    if (group == null) {
      throw new ApiException(
          "Missing the required parameter 'group' when calling replaceClusterCustomObjectStatus(Async)");
    }

    // verify the required parameter 'version' is set
    if (version == null) {
      throw new ApiException(
          "Missing the required parameter 'version' when calling replaceClusterCustomObjectStatus(Async)");
    }

    // verify the required parameter 'plural' is set
    if (plural == null) {
      throw new ApiException(
          "Missing the required parameter 'plural' when calling replaceClusterCustomObjectStatus(Async)");
    }

    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(
          "Missing the required parameter 'name' when calling replaceClusterCustomObjectStatus(Async)");
    }

    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(
          "Missing the required parameter 'body' when calling replaceClusterCustomObjectStatus(Async)");
    }

    Call call =
        replaceClusterCustomObjectStatusCall(
            group, version, plural, name, body, progressListener, progressRequestListener);
    return call;
  }

  /**
   * replace status of the cluster scoped specified custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body (required)
   * @return Object
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public Object replaceClusterCustomObjectStatus(
      String group, String version, String plural, String name, Object body) throws ApiException {
    ApiResponse<Object> resp =
        replaceClusterCustomObjectStatusWithHttpInfo(group, version, plural, name, body);
    return resp.getData();
  }

  /**
   * replace status of the cluster scoped specified custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body (required)
   * @return ApiResponse&lt;Object&gt;
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public ApiResponse<Object> replaceClusterCustomObjectStatusWithHttpInfo(
      String group, String version, String plural, String name, Object body) throws ApiException {
    Call call =
        replaceClusterCustomObjectStatusValidateBeforeCall(
            group, version, plural, name, body, null, null);
    Type localVarReturnType = new TypeToken<Object>() {}.getType();
    return apiClient.execute(call, localVarReturnType);
  }

  /**
   * (asynchronously) replace status of the cluster scoped specified custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body (required)
   * @param callback The callback to be executed when the API call finishes
   * @return The request call
   * @throws ApiException If fail to process the API call, e.g. serializing the request body object
   */
  public Call replaceClusterCustomObjectStatusAsync(
      String group,
      String version,
      String plural,
      String name,
      Object body,
      final ApiCallback<Object> callback)
      throws ApiException {

    ProgressResponseBody.ProgressListener progressListener = null;
    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

    if (callback != null) {
      progressListener =
          new ProgressResponseBody.ProgressListener() {
            @Override
            public void update(long bytesRead, long contentLength, boolean done) {
              callback.onDownloadProgress(bytesRead, contentLength, done);
            }
          };

      progressRequestListener =
          new ProgressRequestBody.ProgressRequestListener() {
            @Override
            public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
              callback.onUploadProgress(bytesWritten, contentLength, done);
            }
          };
    }

    Call call =
        replaceClusterCustomObjectStatusValidateBeforeCall(
            group, version, plural, name, body, progressListener, progressRequestListener);
    Type localVarReturnType = new TypeToken<Object>() {}.getType();
    apiClient.executeAsync(call, localVarReturnType, callback);
    return call;
  }
  /**
   * Build call for replaceNamespacedCustomObject
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param namespace The custom resource&#39;s namespace (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body The JSON schema of the Resource to replace. (required)
   * @param progressListener Progress listener
   * @param progressRequestListener Progress request listener
   * @return Call to execute
   * @throws ApiException If fail to serialize the request body object
   */
  public Call replaceNamespacedCustomObjectCall(
      String group,
      String version,
      String namespace,
      String plural,
      String name,
      Object body,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {
    Object localVarPostBody = body;

    // create path and map variables
    String localVarPath =
        "/apis/{group}/{version}/namespaces/{namespace}/{plural}/{name}"
            .replaceAll("\\{" + "group" + "\\}", apiClient.escapeString(group.toString()))
            .replaceAll("\\{" + "version" + "\\}", apiClient.escapeString(version.toString()))
            .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(namespace.toString()))
            .replaceAll("\\{" + "plural" + "\\}", apiClient.escapeString(plural.toString()))
            .replaceAll("\\{" + "name" + "\\}", apiClient.escapeString(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

    Map<String, String> localVarHeaderParams = new HashMap<String, String>();

    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    final String[] localVarAccepts = {"application/json"};
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
    if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

    final String[] localVarContentTypes = {"*/*"};
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
    localVarHeaderParams.put("Content-Type", localVarContentType);

    if (progressListener != null) {
      apiClient
          .getHttpClient()
          .networkInterceptors()
          .add(
              new Interceptor() {
                @Override
                public Response intercept(Interceptor.Chain chain) throws IOException {
                  Response originalResponse = chain.proceed(chain.request());
                  return originalResponse
                      .newBuilder()
                      .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                      .build();
                }
              });
    }

    String[] localVarAuthNames = new String[] {"BearerToken"};
    return apiClient.buildCall(
        localVarPath,
        "PUT",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarFormParams,
        localVarAuthNames,
        progressRequestListener);
  }

  @SuppressWarnings("rawtypes")
  private Call replaceNamespacedCustomObjectValidateBeforeCall(
      String group,
      String version,
      String namespace,
      String plural,
      String name,
      Object body,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {

    // verify the required parameter 'group' is set
    if (group == null) {
      throw new ApiException(
          "Missing the required parameter 'group' when calling replaceNamespacedCustomObject(Async)");
    }

    // verify the required parameter 'version' is set
    if (version == null) {
      throw new ApiException(
          "Missing the required parameter 'version' when calling replaceNamespacedCustomObject(Async)");
    }

    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(
          "Missing the required parameter 'namespace' when calling replaceNamespacedCustomObject(Async)");
    }

    // verify the required parameter 'plural' is set
    if (plural == null) {
      throw new ApiException(
          "Missing the required parameter 'plural' when calling replaceNamespacedCustomObject(Async)");
    }

    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(
          "Missing the required parameter 'name' when calling replaceNamespacedCustomObject(Async)");
    }

    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(
          "Missing the required parameter 'body' when calling replaceNamespacedCustomObject(Async)");
    }

    Call call =
        replaceNamespacedCustomObjectCall(
            group,
            version,
            namespace,
            plural,
            name,
            body,
            progressListener,
            progressRequestListener);
    return call;
  }

  /**
   * replace the specified namespace scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param namespace The custom resource&#39;s namespace (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body The JSON schema of the Resource to replace. (required)
   * @return Object
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public Object replaceNamespacedCustomObject(
      String group, String version, String namespace, String plural, String name, Object body)
      throws ApiException {
    ApiResponse<Object> resp =
        replaceNamespacedCustomObjectWithHttpInfo(group, version, namespace, plural, name, body);
    return resp.getData();
  }

  /**
   * replace the specified namespace scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param namespace The custom resource&#39;s namespace (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body The JSON schema of the Resource to replace. (required)
   * @return ApiResponse&lt;Object&gt;
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public ApiResponse<Object> replaceNamespacedCustomObjectWithHttpInfo(
      String group, String version, String namespace, String plural, String name, Object body)
      throws ApiException {
    Call call =
        replaceNamespacedCustomObjectValidateBeforeCall(
            group, version, namespace, plural, name, body, null, null);
    Type localVarReturnType = new TypeToken<Object>() {}.getType();
    return apiClient.execute(call, localVarReturnType);
  }

  /**
   * (asynchronously) replace the specified namespace scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param namespace The custom resource&#39;s namespace (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body The JSON schema of the Resource to replace. (required)
   * @param callback The callback to be executed when the API call finishes
   * @return The request call
   * @throws ApiException If fail to process the API call, e.g. serializing the request body object
   */
  public Call replaceNamespacedCustomObjectAsync(
      String group,
      String version,
      String namespace,
      String plural,
      String name,
      Object body,
      final ApiCallback<Object> callback)
      throws ApiException {

    ProgressResponseBody.ProgressListener progressListener = null;
    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

    if (callback != null) {
      progressListener =
          new ProgressResponseBody.ProgressListener() {
            @Override
            public void update(long bytesRead, long contentLength, boolean done) {
              callback.onDownloadProgress(bytesRead, contentLength, done);
            }
          };

      progressRequestListener =
          new ProgressRequestBody.ProgressRequestListener() {
            @Override
            public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
              callback.onUploadProgress(bytesWritten, contentLength, done);
            }
          };
    }

    Call call =
        replaceNamespacedCustomObjectValidateBeforeCall(
            group,
            version,
            namespace,
            plural,
            name,
            body,
            progressListener,
            progressRequestListener);
    Type localVarReturnType = new TypeToken<Object>() {}.getType();
    apiClient.executeAsync(call, localVarReturnType, callback);
    return call;
  }
  /**
   * Build call for replaceNamespacedCustomObjectScale
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param namespace The custom resource&#39;s namespace (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body (required)
   * @param progressListener Progress listener
   * @param progressRequestListener Progress request listener
   * @return Call to execute
   * @throws ApiException If fail to serialize the request body object
   */
  public Call replaceNamespacedCustomObjectScaleCall(
      String group,
      String version,
      String namespace,
      String plural,
      String name,
      Object body,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {
    Object localVarPostBody = body;

    // create path and map variables
    String localVarPath =
        "/apis/{group}/{version}/namespaces/{namespace}/{plural}/{name}/scale"
            .replaceAll("\\{" + "group" + "\\}", apiClient.escapeString(group.toString()))
            .replaceAll("\\{" + "version" + "\\}", apiClient.escapeString(version.toString()))
            .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(namespace.toString()))
            .replaceAll("\\{" + "plural" + "\\}", apiClient.escapeString(plural.toString()))
            .replaceAll("\\{" + "name" + "\\}", apiClient.escapeString(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

    Map<String, String> localVarHeaderParams = new HashMap<String, String>();

    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    final String[] localVarAccepts = {
      "application/json", "application/yaml", "application/vnd.kubernetes.protobuf"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
    if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

    final String[] localVarContentTypes = {"*/*"};
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
    localVarHeaderParams.put("Content-Type", localVarContentType);

    if (progressListener != null) {
      apiClient
          .getHttpClient()
          .networkInterceptors()
          .add(
              new Interceptor() {
                @Override
                public Response intercept(Interceptor.Chain chain) throws IOException {
                  Response originalResponse = chain.proceed(chain.request());
                  return originalResponse
                      .newBuilder()
                      .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                      .build();
                }
              });
    }

    String[] localVarAuthNames = new String[] {"BearerToken"};
    return apiClient.buildCall(
        localVarPath,
        "PUT",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarFormParams,
        localVarAuthNames,
        progressRequestListener);
  }

  @SuppressWarnings("rawtypes")
  private Call replaceNamespacedCustomObjectScaleValidateBeforeCall(
      String group,
      String version,
      String namespace,
      String plural,
      String name,
      Object body,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {

    // verify the required parameter 'group' is set
    if (group == null) {
      throw new ApiException(
          "Missing the required parameter 'group' when calling replaceNamespacedCustomObjectScale(Async)");
    }

    // verify the required parameter 'version' is set
    if (version == null) {
      throw new ApiException(
          "Missing the required parameter 'version' when calling replaceNamespacedCustomObjectScale(Async)");
    }

    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(
          "Missing the required parameter 'namespace' when calling replaceNamespacedCustomObjectScale(Async)");
    }

    // verify the required parameter 'plural' is set
    if (plural == null) {
      throw new ApiException(
          "Missing the required parameter 'plural' when calling replaceNamespacedCustomObjectScale(Async)");
    }

    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(
          "Missing the required parameter 'name' when calling replaceNamespacedCustomObjectScale(Async)");
    }

    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(
          "Missing the required parameter 'body' when calling replaceNamespacedCustomObjectScale(Async)");
    }

    Call call =
        replaceNamespacedCustomObjectScaleCall(
            group,
            version,
            namespace,
            plural,
            name,
            body,
            progressListener,
            progressRequestListener);
    return call;
  }

  /**
   * replace scale of the specified namespace scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param namespace The custom resource&#39;s namespace (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body (required)
   * @return Object
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public Object replaceNamespacedCustomObjectScale(
      String group, String version, String namespace, String plural, String name, Object body)
      throws ApiException {
    ApiResponse<Object> resp =
        replaceNamespacedCustomObjectScaleWithHttpInfo(
            group, version, namespace, plural, name, body);
    return resp.getData();
  }

  /**
   * replace scale of the specified namespace scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param namespace The custom resource&#39;s namespace (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body (required)
   * @return ApiResponse&lt;Object&gt;
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public ApiResponse<Object> replaceNamespacedCustomObjectScaleWithHttpInfo(
      String group, String version, String namespace, String plural, String name, Object body)
      throws ApiException {
    Call call =
        replaceNamespacedCustomObjectScaleValidateBeforeCall(
            group, version, namespace, plural, name, body, null, null);
    Type localVarReturnType = new TypeToken<Object>() {}.getType();
    return apiClient.execute(call, localVarReturnType);
  }

  /**
   * (asynchronously) replace scale of the specified namespace scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param namespace The custom resource&#39;s namespace (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body (required)
   * @param callback The callback to be executed when the API call finishes
   * @return The request call
   * @throws ApiException If fail to process the API call, e.g. serializing the request body object
   */
  public Call replaceNamespacedCustomObjectScaleAsync(
      String group,
      String version,
      String namespace,
      String plural,
      String name,
      Object body,
      final ApiCallback<Object> callback)
      throws ApiException {

    ProgressResponseBody.ProgressListener progressListener = null;
    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

    if (callback != null) {
      progressListener =
          new ProgressResponseBody.ProgressListener() {
            @Override
            public void update(long bytesRead, long contentLength, boolean done) {
              callback.onDownloadProgress(bytesRead, contentLength, done);
            }
          };

      progressRequestListener =
          new ProgressRequestBody.ProgressRequestListener() {
            @Override
            public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
              callback.onUploadProgress(bytesWritten, contentLength, done);
            }
          };
    }

    Call call =
        replaceNamespacedCustomObjectScaleValidateBeforeCall(
            group,
            version,
            namespace,
            plural,
            name,
            body,
            progressListener,
            progressRequestListener);
    Type localVarReturnType = new TypeToken<Object>() {}.getType();
    apiClient.executeAsync(call, localVarReturnType, callback);
    return call;
  }
  /**
   * Build call for replaceNamespacedCustomObjectStatus
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param namespace The custom resource&#39;s namespace (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body (required)
   * @param progressListener Progress listener
   * @param progressRequestListener Progress request listener
   * @return Call to execute
   * @throws ApiException If fail to serialize the request body object
   */
  public Call replaceNamespacedCustomObjectStatusCall(
      String group,
      String version,
      String namespace,
      String plural,
      String name,
      Object body,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {
    Object localVarPostBody = body;

    // create path and map variables
    String localVarPath =
        "/apis/{group}/{version}/namespaces/{namespace}/{plural}/{name}/status"
            .replaceAll("\\{" + "group" + "\\}", apiClient.escapeString(group.toString()))
            .replaceAll("\\{" + "version" + "\\}", apiClient.escapeString(version.toString()))
            .replaceAll("\\{" + "namespace" + "\\}", apiClient.escapeString(namespace.toString()))
            .replaceAll("\\{" + "plural" + "\\}", apiClient.escapeString(plural.toString()))
            .replaceAll("\\{" + "name" + "\\}", apiClient.escapeString(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

    Map<String, String> localVarHeaderParams = new HashMap<String, String>();

    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    final String[] localVarAccepts = {
      "application/json", "application/yaml", "application/vnd.kubernetes.protobuf"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
    if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

    final String[] localVarContentTypes = {"*/*"};
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
    localVarHeaderParams.put("Content-Type", localVarContentType);

    if (progressListener != null) {
      apiClient
          .getHttpClient()
          .networkInterceptors()
          .add(
              new Interceptor() {
                @Override
                public Response intercept(Interceptor.Chain chain) throws IOException {
                  Response originalResponse = chain.proceed(chain.request());
                  return originalResponse
                      .newBuilder()
                      .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                      .build();
                }
              });
    }

    String[] localVarAuthNames = new String[] {"BearerToken"};
    return apiClient.buildCall(
        localVarPath,
        "PUT",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarPostBody,
        localVarHeaderParams,
        localVarFormParams,
        localVarAuthNames,
        progressRequestListener);
  }

  @SuppressWarnings("rawtypes")
  private Call replaceNamespacedCustomObjectStatusValidateBeforeCall(
      String group,
      String version,
      String namespace,
      String plural,
      String name,
      Object body,
      final ProgressResponseBody.ProgressListener progressListener,
      final ProgressRequestBody.ProgressRequestListener progressRequestListener)
      throws ApiException {

    // verify the required parameter 'group' is set
    if (group == null) {
      throw new ApiException(
          "Missing the required parameter 'group' when calling replaceNamespacedCustomObjectStatus(Async)");
    }

    // verify the required parameter 'version' is set
    if (version == null) {
      throw new ApiException(
          "Missing the required parameter 'version' when calling replaceNamespacedCustomObjectStatus(Async)");
    }

    // verify the required parameter 'namespace' is set
    if (namespace == null) {
      throw new ApiException(
          "Missing the required parameter 'namespace' when calling replaceNamespacedCustomObjectStatus(Async)");
    }

    // verify the required parameter 'plural' is set
    if (plural == null) {
      throw new ApiException(
          "Missing the required parameter 'plural' when calling replaceNamespacedCustomObjectStatus(Async)");
    }

    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(
          "Missing the required parameter 'name' when calling replaceNamespacedCustomObjectStatus(Async)");
    }

    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(
          "Missing the required parameter 'body' when calling replaceNamespacedCustomObjectStatus(Async)");
    }

    Call call =
        replaceNamespacedCustomObjectStatusCall(
            group,
            version,
            namespace,
            plural,
            name,
            body,
            progressListener,
            progressRequestListener);
    return call;
  }

  /**
   * replace status of the specified namespace scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param namespace The custom resource&#39;s namespace (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body (required)
   * @return Object
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public Object replaceNamespacedCustomObjectStatus(
      String group, String version, String namespace, String plural, String name, Object body)
      throws ApiException {
    ApiResponse<Object> resp =
        replaceNamespacedCustomObjectStatusWithHttpInfo(
            group, version, namespace, plural, name, body);
    return resp.getData();
  }

  /**
   * replace status of the specified namespace scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param namespace The custom resource&#39;s namespace (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body (required)
   * @return ApiResponse&lt;Object&gt;
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *     response body
   */
  public ApiResponse<Object> replaceNamespacedCustomObjectStatusWithHttpInfo(
      String group, String version, String namespace, String plural, String name, Object body)
      throws ApiException {
    Call call =
        replaceNamespacedCustomObjectStatusValidateBeforeCall(
            group, version, namespace, plural, name, body, null, null);
    Type localVarReturnType = new TypeToken<Object>() {}.getType();
    return apiClient.execute(call, localVarReturnType);
  }

  /**
   * (asynchronously) replace status of the specified namespace scoped custom object
   *
   * @param group the custom resource&#39;s group (required)
   * @param version the custom resource&#39;s version (required)
   * @param namespace The custom resource&#39;s namespace (required)
   * @param plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural
   *     kind. (required)
   * @param name the custom object&#39;s name (required)
   * @param body (required)
   * @param callback The callback to be executed when the API call finishes
   * @return The request call
   * @throws ApiException If fail to process the API call, e.g. serializing the request body object
   */
  public Call replaceNamespacedCustomObjectStatusAsync(
      String group,
      String version,
      String namespace,
      String plural,
      String name,
      Object body,
      final ApiCallback<Object> callback)
      throws ApiException {

    ProgressResponseBody.ProgressListener progressListener = null;
    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

    if (callback != null) {
      progressListener =
          new ProgressResponseBody.ProgressListener() {
            @Override
            public void update(long bytesRead, long contentLength, boolean done) {
              callback.onDownloadProgress(bytesRead, contentLength, done);
            }
          };

      progressRequestListener =
          new ProgressRequestBody.ProgressRequestListener() {
            @Override
            public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
              callback.onUploadProgress(bytesWritten, contentLength, done);
            }
          };
    }

    Call call =
        replaceNamespacedCustomObjectStatusValidateBeforeCall(
            group,
            version,
            namespace,
            plural,
            name,
            body,
            progressListener,
            progressRequestListener);
    Type localVarReturnType = new TypeToken<Object>() {}.getType();
    apiClient.executeAsync(call, localVarReturnType, callback);
    return call;
  }
}
